"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("vendors-node_modules_next_dist_b",{

/***/ "../../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js ***!
  \*********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    PrefetchKind: function() {\n        return PrefetchKind;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    ACTION_PREFETCH: function() {\n        return ACTION_PREFETCH;\n    },\n    ACTION_FAST_REFRESH: function() {\n        return ACTION_FAST_REFRESH;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    }\n});\nconst ACTION_REFRESH = \"refresh\";\nconst ACTION_NAVIGATE = \"navigate\";\nconst ACTION_RESTORE = \"restore\";\nconst ACTION_SERVER_PATCH = \"server-patch\";\nconst ACTION_PREFETCH = \"prefetch\";\nconst ACTION_FAST_REFRESH = \"fast-refresh\";\nconst ACTION_SERVER_ACTION = \"server-action\";\nvar PrefetchKind;\n(function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n})(PrefetchKind || (PrefetchKind = {}));\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQVNOO0FBQ0EsU0FBU1MsUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSWYsT0FBT0MsY0FBYyxDQUFDYSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFYLFNBQVM7SUFDYkcsY0FBYztRQUNWLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7SUFDQUMscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsaUJBQWlCO1FBQ2IsT0FBT0E7SUFDWDtJQUNBQyxxQkFBcUI7UUFDakIsT0FBT0E7SUFDWDtJQUNBQyxzQkFBc0I7UUFDbEIsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU4saUJBQWlCO0FBQ3ZCLE1BQU1DLGtCQUFrQjtBQUN4QixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsc0JBQXNCO0FBQzVCLE1BQU1DLGtCQUFrQjtBQUN4QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsdUJBQXVCO0FBQzdCLElBQUlQO0FBQ0gsVUFBU0EsWUFBWTtJQUNsQkEsWUFBWSxDQUFDLE9BQU8sR0FBRztJQUN2QkEsWUFBWSxDQUFDLE9BQU8sR0FBRztJQUN2QkEsWUFBWSxDQUFDLFlBQVksR0FBRztBQUNoQyxHQUFHQSxnQkFBaUJBLENBQUFBLGVBQWUsQ0FBQztBQUVwQyxJQUFJLENBQUMsT0FBT0gsUUFBUWlCLE9BQU8sS0FBSyxjQUFlLE9BQU9qQixRQUFRaUIsT0FBTyxLQUFLLFlBQVlqQixRQUFRaUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPakIsUUFBUWlCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktwQixPQUFPQyxjQUFjLENBQUNDLFFBQVFpQixPQUFPLEVBQUUsY0FBYztRQUFFaEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPcUIsTUFBTSxDQUFDbkIsUUFBUWlCLE9BQU8sRUFBRWpCO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVFpQixPQUFPO0FBQ2xDLEVBRUEsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzLmpzPzAzMDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQcmVmZXRjaEtpbmQ6IG51bGwsXG4gICAgQUNUSU9OX1JFRlJFU0g6IG51bGwsXG4gICAgQUNUSU9OX05BVklHQVRFOiBudWxsLFxuICAgIEFDVElPTl9SRVNUT1JFOiBudWxsLFxuICAgIEFDVElPTl9TRVJWRVJfUEFUQ0g6IG51bGwsXG4gICAgQUNUSU9OX1BSRUZFVENIOiBudWxsLFxuICAgIEFDVElPTl9GQVNUX1JFRlJFU0g6IG51bGwsXG4gICAgQUNUSU9OX1NFUlZFUl9BQ1RJT046IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgUHJlZmV0Y2hLaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByZWZldGNoS2luZDtcbiAgICB9LFxuICAgIEFDVElPTl9SRUZSRVNIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9SRUZSRVNIO1xuICAgIH0sXG4gICAgQUNUSU9OX05BVklHQVRFOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9OQVZJR0FURTtcbiAgICB9LFxuICAgIEFDVElPTl9SRVNUT1JFOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9SRVNUT1JFO1xuICAgIH0sXG4gICAgQUNUSU9OX1NFUlZFUl9QQVRDSDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fU0VSVkVSX1BBVENIO1xuICAgIH0sXG4gICAgQUNUSU9OX1BSRUZFVENIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9QUkVGRVRDSDtcbiAgICB9LFxuICAgIEFDVElPTl9GQVNUX1JFRlJFU0g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX0ZBU1RfUkVGUkVTSDtcbiAgICB9LFxuICAgIEFDVElPTl9TRVJWRVJfQUNUSU9OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9TRVJWRVJfQUNUSU9OO1xuICAgIH1cbn0pO1xuY29uc3QgQUNUSU9OX1JFRlJFU0ggPSBcInJlZnJlc2hcIjtcbmNvbnN0IEFDVElPTl9OQVZJR0FURSA9IFwibmF2aWdhdGVcIjtcbmNvbnN0IEFDVElPTl9SRVNUT1JFID0gXCJyZXN0b3JlXCI7XG5jb25zdCBBQ1RJT05fU0VSVkVSX1BBVENIID0gXCJzZXJ2ZXItcGF0Y2hcIjtcbmNvbnN0IEFDVElPTl9QUkVGRVRDSCA9IFwicHJlZmV0Y2hcIjtcbmNvbnN0IEFDVElPTl9GQVNUX1JFRlJFU0ggPSBcImZhc3QtcmVmcmVzaFwiO1xuY29uc3QgQUNUSU9OX1NFUlZFUl9BQ1RJT04gPSBcInNlcnZlci1hY3Rpb25cIjtcbnZhciBQcmVmZXRjaEtpbmQ7XG4oZnVuY3Rpb24oUHJlZmV0Y2hLaW5kKSB7XG4gICAgUHJlZmV0Y2hLaW5kW1wiQVVUT1wiXSA9IFwiYXV0b1wiO1xuICAgIFByZWZldGNoS2luZFtcIkZVTExcIl0gPSBcImZ1bGxcIjtcbiAgICBQcmVmZXRjaEtpbmRbXCJURU1QT1JBUllcIl0gPSBcInRlbXBvcmFyeVwiO1xufSkoUHJlZmV0Y2hLaW5kIHx8IChQcmVmZXRjaEtpbmQgPSB7fSkpO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItcmVkdWNlci10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJQcmVmZXRjaEtpbmQiLCJBQ1RJT05fUkVGUkVTSCIsIkFDVElPTl9OQVZJR0FURSIsIkFDVElPTl9SRVNUT1JFIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsIkFDVElPTl9QUkVGRVRDSCIsIkFDVElPTl9GQVNUX1JFRlJFU0giLCJBQ1RJT05fU0VSVkVSX0FDVElPTiIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\n"));

/***/ }),

/***/ "../../node_modules/next/dist/client/get-domain-locale.js":
/*!****************************************************************!*\
  !*** ../../node_modules/next/dist/client/get-domain-locale.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"../../node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDBCQUEwQkMsbUJBQU9BLENBQUMsbUdBQTRCO0FBQ3BFLE1BQU1DLFdBQVdDLE1BQWtDLElBQUk7QUFDdkQsU0FBU0osZ0JBQWdCTyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxhQUFhO0lBQ3pELElBQUlOLEtBQStCLEVBQUUsRUFXcEMsTUFBTTtRQUNILE9BQU87SUFDWDtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9SLFFBQVEyQixPQUFPLEtBQUssY0FBZSxPQUFPM0IsUUFBUTJCLE9BQU8sS0FBSyxZQUFZM0IsUUFBUTJCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzNCLFFBQVEyQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLOUIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRMkIsT0FBTyxFQUFFLGNBQWM7UUFBRTFCLE9BQU87SUFBSztJQUNuRUgsT0FBTytCLE1BQU0sQ0FBQzdCLFFBQVEyQixPQUFPLEVBQUUzQjtJQUMvQjhCLE9BQU85QixPQUFPLEdBQUdBLFFBQVEyQixPQUFPO0FBQ2xDLEVBRUEsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcz8wZDA0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RG9tYWluTG9jYWxlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXREb21haW5Mb2NhbGU7XG4gICAgfVxufSk7XG5jb25zdCBfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIikubm9ybWFsaXplTG9jYWxlUGF0aDtcbiAgICAgICAgY29uc3QgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4vZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIikuZGV0ZWN0RG9tYWluTG9jYWxlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhbGUgfHwgbm9ybWFsaXplTG9jYWxlUGF0aChwYXRoLCBsb2NhbGVzKS5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgY29uc3QgZG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBcImh0dHBcIiArIChkb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiO1xuICAgICAgICAgICAgY29uc3QgZmluYWxMb2NhbGUgPSB0YXJnZXQgPT09IGRvbWFpbi5kZWZhdWx0TG9jYWxlID8gXCJcIiA6IFwiL1wiICsgdGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBwcm90byArIGRvbWFpbi5kb21haW4gKyAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKFwiXCIgKyBiYXNlUGF0aCArIGZpbmFsTG9jYWxlICsgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1kb21haW4tbG9jYWxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJnZXREb21haW5Mb2NhbGUiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsInJlcXVpcmUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJ0YXJnZXQiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsInVuZGVmaW5lZCIsInByb3RvIiwiaHR0cCIsImZpbmFsTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "../../node_modules/next/dist/client/image-component.js":
/*!**************************************************************!*\
  !*** ../../node_modules/next/dist/client/image-component.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"../../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"../../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"../../node_modules/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"../../node_modules/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"../../node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"../../node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"../../node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"../../node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"../../node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"../../node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"../../node_modules/next/dist/shared/lib/image-loader.js\"));\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"localhost\"],\"remotePatterns\":[]};\nif (false) {}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== \"empty\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, \"http://n\").searchParams.get(\"url\") || src;\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!img.getAttribute(\"sizes\") || img.getAttribute(\"sizes\") === \"100vw\")) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            const widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    const [majorStr, minorStr] = _react.version.split(\".\");\n    const major = parseInt(majorStr, 10);\n    const minor = parseInt(minorStr, 10);\n    if (major > 18 || major === 18 && minor >= 3) {\n        // In React 18.3.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, onLoad, onError, ...rest } = param;\n    return /*#__PURE__*/ _react.default.createElement(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: (0, _react.useCallback)((img)=>{\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!src) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n            }\n        }, [\n            src,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            forwardedRef\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== \"empty\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\n_c = ImageElement;\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: \"image\",\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ _react.default.createElement(_head.default, null, /*#__PURE__*/ _react.default.createElement(\"link\", {\n        key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n        rel: \"preload\",\n        // Note how we omit the `href` attribute, as it would only be relevant\n        // for browsers that do not support `imagesrcset`, and in those cases\n        // it would cause the incorrect image to be preloaded.\n        //\n        // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n        href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n        ...opts\n    }));\n}\n_c1 = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(ImageElement, {\n        ...imgAttributes,\n        unoptimized: imgMeta.unoptimized,\n        placeholder: imgMeta.placeholder,\n        fill: imgMeta.fill,\n        onLoadRef: onLoadRef,\n        onLoadingCompleteRef: onLoadingCompleteRef,\n        setBlurComplete: setBlurComplete,\n        setShowAltText: setShowAltText,\n        ref: forwardedRef\n    }), imgMeta.priority ? /*#__PURE__*/ _react.default.createElement(ImagePreload, {\n        isAppRouter: isAppRouter,\n        imgAttributes: imgAttributes\n    }) : null);\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"ImageElement\");\n$RefreshReg$(_c1, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW1hZ2UtY29tcG9uZW50LmpzIiwibWFwcGluZ3MiOiJxREFFYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgseUNBQXdDO0lBQ3BDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSEFBeUM7QUFDbEYsTUFBTUMsNEJBQTRCRCxtQkFBT0EsQ0FBQyxrSEFBMEM7QUFDcEYsTUFBTUUsU0FBUyxXQUFXLEdBQUdELDBCQUEwQkUsQ0FBQyxDQUFDSCxtQkFBT0EsQ0FBQyxnREFBTztBQUN4RSxNQUFNSSxZQUFZLFdBQVcsR0FBR0wseUJBQXlCSSxDQUFDLENBQUNILG1CQUFPQSxDQUFDLHdEQUFXO0FBQzlFLE1BQU1LLFFBQVEsV0FBVyxHQUFHTix5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsMkVBQW9CO0FBQ25GLE1BQU1NLGVBQWVOLG1CQUFPQSxDQUFDLDZGQUE2QjtBQUMxRCxNQUFNTyxlQUFlUCxtQkFBT0EsQ0FBQywyRkFBNEI7QUFDekQsTUFBTVEsbUNBQW1DUixtQkFBT0EsQ0FBQyx5SUFBbUQ7QUFDcEcsTUFBTVMsWUFBWVQsbUJBQU9BLENBQUMsaUdBQStCO0FBQ3pELE1BQU1VLDhCQUE4QlYsbUJBQU9BLENBQUMsNkhBQTZDO0FBQ3pGLE1BQU1XLGVBQWUsV0FBVyxHQUFHWix5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsa0dBQW1DO0FBQ3pHLDRDQUE0QztBQUM1QyxNQUFNWSxZQUFZQyxxT0FBNkI7QUFDL0MsSUFBSSxLQUE2QixFQUFFLEVBRWxDO0FBQ0QsMEVBQTBFO0FBQzFFLGlEQUFpRDtBQUNqRCxTQUFTSyxjQUFjQyxHQUFHLEVBQUVDLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxvQkFBb0IsRUFBRUMsZUFBZSxFQUFFQyxXQUFX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QUNyS3ZKLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW9HLE9BQU8sRUFBRSxjQUFjO1FBQUVuRyxPQUFPO0lBQUs7SUFDbkVILE9BQU93SixNQUFNLENBQUN0SixRQUFRb0csT0FBTyxFQUFFcEc7SUFDL0J1SixPQUFPdkosT0FBTyxHQUFHQSxRQUFRb0csT0FBTztBQUNsQyxFQUVBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW1hZ2UtY29tcG9uZW50LmpzP2Q2ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1hZ2VcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEltYWdlO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfcmVhY3Rkb20gPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xuY29uc3QgX2hlYWQgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWRcIikpO1xuY29uc3QgX2dldGltZ3Byb3BzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wc1wiKTtcbmNvbnN0IF9pbWFnZWNvbmZpZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZ1wiKTtcbmNvbnN0IF9pbWFnZWNvbmZpZ2NvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfd2Fybm9uY2UgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlscy93YXJuLW9uY2VcIik7XG5jb25zdCBfcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9pbWFnZWxvYWRlciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIm5leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWxvYWRlclwiKSk7XG4vLyBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgZGVmaW5lIHBsdWdpblxuY29uc3QgY29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFM7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGdsb2JhbFRoaXMuX19ORVhUX0lNQUdFX0lNUE9SVEVEID0gdHJ1ZTtcbn1cbi8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzk3Nzc4MzMvMjY2NTM1IGZvciB3aHkgd2UgdXNlIHRoaXMgcmVmXG4vLyBoYW5kbGVyIGluc3RlYWQgb2YgdGhlIGltZydzIG9uTG9hZCBhdHRyaWJ1dGUuXG5mdW5jdGlvbiBoYW5kbGVMb2FkaW5nKGltZywgcGxhY2Vob2xkZXIsIG9uTG9hZFJlZiwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSwgdW5vcHRpbWl6ZWQpIHtcbiAgICBjb25zdCBzcmMgPSBpbWcgPT0gbnVsbCA/IHZvaWQgMCA6IGltZy5zcmM7XG4gICAgaWYgKCFpbWcgfHwgaW1nW1wiZGF0YS1sb2FkZWQtc3JjXCJdID09PSBzcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbWdbXCJkYXRhLWxvYWRlZC1zcmNcIl0gPSBzcmM7XG4gICAgY29uc3QgcCA9IFwiZGVjb2RlXCIgaW4gaW1nID8gaW1nLmRlY29kZSgpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgcC5jYXRjaCgoKT0+e30pLnRoZW4oKCk9PntcbiAgICAgICAgaWYgKCFpbWcucGFyZW50RWxlbWVudCB8fCAhaW1nLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGluIGNhc2Ugb2YgcmFjZSBjb25kaXRpb246XG4gICAgICAgICAgICAvLyAtIG9ubG9hZCgpIGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBpcyBjYWxsZWQgYnV0IGluY29tcGxldGVcbiAgICAgICAgICAgIC8vIC0gdW5tb3VudCBpcyBjYWxsZWRcbiAgICAgICAgICAgIC8vIC0gZGVjb2RlKCkgY29tcGxldGVzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyICE9PSBcImVtcHR5XCIpIHtcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkUmVmID09IG51bGwgPyB2b2lkIDAgOiBvbkxvYWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3QgaGF2ZSB0aGUgU3ludGhldGljRXZlbnQgaGVyZSxcbiAgICAgICAgICAgIC8vIHdlIG11c3QgY3JlYXRlIG9uZSB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ldmVudHMuaHRtbFxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoXCJsb2FkXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCBcInRhcmdldFwiLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG9uTG9hZFJlZi5jdXJyZW50KHtcbiAgICAgICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogaW1nLFxuICAgICAgICAgICAgICAgIHRhcmdldDogaW1nLFxuICAgICAgICAgICAgICAgIGlzRGVmYXVsdFByZXZlbnRlZDogKCk9PnByZXZlbnRlZCxcbiAgICAgICAgICAgICAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogKCk9PnN0b3BwZWQsXG4gICAgICAgICAgICAgICAgcGVyc2lzdDogKCk9Pnt9LFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiAoKT0+e1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAoKT0+e1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlUmVmID09IG51bGwgPyB2b2lkIDAgOiBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KGltZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ1NyYyA9IG5ldyBVUkwoc3JjLCBcImh0dHA6Ly9uXCIpLnNlYXJjaFBhcmFtcy5nZXQoXCJ1cmxcIikgfHwgc3JjO1xuICAgICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5pbWdcIikgPT09IFwiZmlsbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bm9wdGltaXplZCAmJiAoIWltZy5nZXRBdHRyaWJ1dGUoXCJzaXplc1wiKSB8fCBpbWcuZ2V0QXR0cmlidXRlKFwic2l6ZXNcIikgPT09IFwiMTAwdndcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoVmlld3BvcnRSYXRpbyA9IGltZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGhWaWV3cG9ydFJhdGlvIDwgMC42KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgb3JpZ1NyYyArICdcIiBoYXMgXCJmaWxsXCIgYnV0IGlzIG1pc3NpbmcgXCJzaXplc1wiIHByb3AuIFBsZWFzZSBhZGQgaXQgdG8gaW1wcm92ZSBwYWdlIHBlcmZvcm1hbmNlLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNzaXplcycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWcucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbWcucGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaXhlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWxhdGl2ZVwiXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQuaW5jbHVkZXMocG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgb3JpZ1NyYyArICdcIiBoYXMgXCJmaWxsXCIgYW5kIHBhcmVudCBlbGVtZW50IHdpdGggaW52YWxpZCBcInBvc2l0aW9uXCIuIFByb3ZpZGVkIFwiJyArIHBvc2l0aW9uICsgJ1wiIHNob3VsZCBiZSBvbmUgb2YgJyArIHZhbGlkLm1hcChTdHJpbmcpLmpvaW4oXCIsXCIpICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWcuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBvcmlnU3JjICsgJ1wiIGhhcyBcImZpbGxcIiBhbmQgYSBoZWlnaHQgdmFsdWUgb2YgMC4gVGhpcyBpcyBsaWtlbHkgYmVjYXVzZSB0aGUgcGFyZW50IGVsZW1lbnQgb2YgdGhlIGltYWdlIGhhcyBub3QgYmVlbiBzdHlsZWQgdG8gaGF2ZSBhIHNldCBoZWlnaHQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0TW9kaWZpZWQgPSBpbWcuaGVpZ2h0LnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIik7XG4gICAgICAgICAgICBjb25zdCB3aWR0aE1vZGlmaWVkID0gaW1nLndpZHRoLnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKTtcbiAgICAgICAgICAgIGlmIChoZWlnaHRNb2RpZmllZCAmJiAhd2lkdGhNb2RpZmllZCB8fCAhaGVpZ2h0TW9kaWZpZWQgJiYgd2lkdGhNb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBvcmlnU3JjICsgJ1wiIGhhcyBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IG1vZGlmaWVkLCBidXQgbm90IHRoZSBvdGhlci4gSWYgeW91IHVzZSBDU1MgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHlvdXIgaW1hZ2UsIGFsc28gaW5jbHVkZSB0aGUgc3R5bGVzIFxcJ3dpZHRoOiBcImF1dG9cIlxcJyBvciBcXCdoZWlnaHQ6IFwiYXV0b1wiXFwnIHRvIG1haW50YWluIHRoZSBhc3BlY3QgcmF0aW8uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldER5bmFtaWNQcm9wcyhmZXRjaFByaW9yaXR5KSB7XG4gICAgY29uc3QgW21ham9yU3RyLCBtaW5vclN0cl0gPSBfcmVhY3QudmVyc2lvbi5zcGxpdChcIi5cIik7XG4gICAgY29uc3QgbWFqb3IgPSBwYXJzZUludChtYWpvclN0ciwgMTApO1xuICAgIGNvbnN0IG1pbm9yID0gcGFyc2VJbnQobWlub3JTdHIsIDEwKTtcbiAgICBpZiAobWFqb3IgPiAxOCB8fCBtYWpvciA9PT0gMTggJiYgbWlub3IgPj0gMykge1xuICAgICAgICAvLyBJbiBSZWFjdCAxOC4zLjAgb3IgbmV3ZXIsIHdlIG11c3QgdXNlIGNhbWVsQ2FzZVxuICAgICAgICAvLyBwcm9wIHRvIGF2b2lkIFwiV2FybmluZzogSW52YWxpZCBET00gcHJvcGVydHlcIi5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI1OTI3XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmZXRjaFByaW9yaXR5XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEluIFJlYWN0IDE4LjIuMCBvciBvbGRlciwgd2UgbXVzdCB1c2UgbG93ZXJjYXNlIHByb3BcbiAgICAvLyB0byBhdm9pZCBcIldhcm5pbmc6IEludmFsaWQgRE9NIHByb3BlcnR5XCIuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmV0Y2hwcmlvcml0eTogZmV0Y2hQcmlvcml0eVxuICAgIH07XG59XG5jb25zdCBJbWFnZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovICgwLCBfcmVhY3QuZm9yd2FyZFJlZikoKHBhcmFtLCBmb3J3YXJkZWRSZWYpPT57XG4gICAgbGV0IHsgc3JjLCBzcmNTZXQsIHNpemVzLCBoZWlnaHQsIHdpZHRoLCBkZWNvZGluZywgY2xhc3NOYW1lLCBzdHlsZSwgZmV0Y2hQcmlvcml0eSwgcGxhY2Vob2xkZXIsIGxvYWRpbmcsIHVub3B0aW1pemVkLCBmaWxsLCBvbkxvYWRSZWYsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUsIHNldFNob3dBbHRUZXh0LCBvbkxvYWQsIG9uRXJyb3IsIC4uLnJlc3QgfSA9IHBhcmFtO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICAuLi5nZXREeW5hbWljUHJvcHMoZmV0Y2hQcmlvcml0eSksXG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgbG9hZGluZ2AgYmVmb3JlIGBzcmNgIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBwcm9wcyBpbiBvcmRlciB3aGljaCBjYXVzZXMgU2FmYXJpL0ZpcmVmb3ggdG8gbm90IGxhenkgbG9hZCBwcm9wZXJseS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjU4ODNcbiAgICAgICAgbG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgZGVjb2Rpbmc6IGRlY29kaW5nLFxuICAgICAgICBcImRhdGEtbmltZ1wiOiBmaWxsID8gXCJmaWxsXCIgOiBcIjFcIixcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgICAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICAgICAgc2l6ZXM6IHNpemVzLFxuICAgICAgICBzcmNTZXQ6IHNyY1NldCxcbiAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgIHJlZjogKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKGltZyk9PntcbiAgICAgICAgICAgIGlmIChmb3J3YXJkZWRSZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gXCJmdW5jdGlvblwiKSBmb3J3YXJkZWRSZWYoaW1nKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSAuY3VycmVudCBpcyByZWFkIG9ubHkgaXQncyB1c3VhbGx5IGFzc2lnbmVkIGJ5IHJlYWN0IGludGVybmFsbHlcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBpbWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgYW4gZXJyb3IgYmVmb3JlIHJlYWN0IGh5ZHJhdGVzLCB0aGVuIHRoZSBlcnJvciBpcyBsb3N0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JrYXJvdW5kIGlzIHRvIHdhaXQgdW50aWwgdGhlIGltYWdlIGlzIG1vdW50ZWQgd2hpY2ggaXMgYWZ0ZXIgaHlkcmF0aW9uLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2V0IHRoZSBzcmMgYWdhaW4gdG8gdHJpZ2dlciB0aGUgZXJyb3IgaGFuZGxlciAoaWYgdGhlcmUgd2FzIGFuIGVycm9yKS5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gaW1nLnNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbWFnZSBpcyBtaXNzaW5nIHJlcXVpcmVkIFwic3JjXCIgcHJvcGVydHk6JywgaW1nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoXCJhbHRcIikgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcImFsdFwiIHByb3BlcnR5LiBQbGVhc2UgYWRkIEFsdGVybmF0aXZlIFRleHQgdG8gZGVzY3JpYmUgdGhlIGltYWdlIGZvciBzY3JlZW4gcmVhZGVycyBhbmQgc2VhcmNoIGVuZ2luZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBwbGFjZWhvbGRlciwgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCB1bm9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgb25Mb2FkUmVmLFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgICAgICBmb3J3YXJkZWRSZWZcbiAgICAgICAgXSksXG4gICAgICAgIG9uTG9hZDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBwbGFjZWhvbGRlciwgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCB1bm9wdGltaXplZCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChldmVudCk9PntcbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBlbnN1cmUgXCJhbHRcIiBpcyB2aXNpYmxlXG4gICAgICAgICAgICBzZXRTaG93QWx0VGV4dCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gXCJlbXB0eVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIHN0aWxsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5mdW5jdGlvbiBJbWFnZVByZWxvYWQocGFyYW0pIHtcbiAgICBsZXQgeyBpc0FwcFJvdXRlciwgaW1nQXR0cmlidXRlcyB9ID0gcGFyYW07XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgYXM6IFwiaW1hZ2VcIixcbiAgICAgICAgaW1hZ2VTcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICBpbWFnZVNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICBjcm9zc09yaWdpbjogaW1nQXR0cmlidXRlcy5jcm9zc09yaWdpbixcbiAgICAgICAgcmVmZXJyZXJQb2xpY3k6IGltZ0F0dHJpYnV0ZXMucmVmZXJyZXJQb2xpY3ksXG4gICAgICAgIC4uLmdldER5bmFtaWNQcm9wcyhpbWdBdHRyaWJ1dGVzLmZldGNoUHJpb3JpdHkpXG4gICAgfTtcbiAgICBpZiAoaXNBcHBSb3V0ZXIgJiYgX3JlYWN0ZG9tLmRlZmF1bHQucHJlbG9hZCkge1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjY5NDBcbiAgICAgICAgX3JlYWN0ZG9tLmRlZmF1bHQucHJlbG9hZChpbWdBdHRyaWJ1dGVzLnNyYywgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiB1cGdyYWRlIHRvIGBAdHlwZXMvcmVhY3QtZG9tQDE4LjMueGBcbiAgICAgICAgb3B0cyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9oZWFkLmRlZmF1bHQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImxpbmtcIiwge1xuICAgICAgICBrZXk6IFwiX19uaW1nLVwiICsgaW1nQXR0cmlidXRlcy5zcmMgKyBpbWdBdHRyaWJ1dGVzLnNyY1NldCArIGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgIC8vIE5vdGUgaG93IHdlIG9taXQgdGhlIGBocmVmYCBhdHRyaWJ1dGUsIGFzIGl0IHdvdWxkIG9ubHkgYmUgcmVsZXZhbnRcbiAgICAgICAgLy8gZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgYGltYWdlc3Jjc2V0YCwgYW5kIGluIHRob3NlIGNhc2VzXG4gICAgICAgIC8vIGl0IHdvdWxkIGNhdXNlIHRoZSBpbmNvcnJlY3QgaW1hZ2UgdG8gYmUgcHJlbG9hZGVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCNhdHRyLWxpbmstaW1hZ2VzcmNzZXRcbiAgICAgICAgaHJlZjogaW1nQXR0cmlidXRlcy5zcmNTZXQgPyB1bmRlZmluZWQgOiBpbWdBdHRyaWJ1dGVzLnNyYyxcbiAgICAgICAgLi4ub3B0c1xuICAgIH0pKTtcbn1cbmNvbnN0IEltYWdlID0gLyojX19QVVJFX18qLyAoMCwgX3JlYWN0LmZvcndhcmRSZWYpKChwcm9wcywgZm9yd2FyZGVkUmVmKT0+e1xuICAgIGNvbnN0IHBhZ2VzUm91dGVyID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuUm91dGVyQ29udGV4dCk7XG4gICAgLy8gV2UncmUgaW4gdGhlIGFwcCBkaXJlY3RvcnkgaWYgdGhlcmUgaXMgbm8gcGFnZXMgcm91dGVyLlxuICAgIGNvbnN0IGlzQXBwUm91dGVyID0gIXBhZ2VzUm91dGVyO1xuICAgIGNvbnN0IGNvbmZpZ0NvbnRleHQgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9pbWFnZWNvbmZpZ2NvbnRleHRzaGFyZWRydW50aW1lLkltYWdlQ29uZmlnQ29udGV4dCk7XG4gICAgY29uc3QgY29uZmlnID0gKDAsIF9yZWFjdC51c2VNZW1vKSgoKT0+e1xuICAgICAgICBjb25zdCBjID0gY29uZmlnRW52IHx8IGNvbmZpZ0NvbnRleHQgfHwgX2ltYWdlY29uZmlnLmltYWdlQ29uZmlnRGVmYXVsdDtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxuICAgICAgICAgICAgLi4uYy5pbWFnZVNpemVzXG4gICAgICAgIF0uc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgYWxsU2l6ZXMsXG4gICAgICAgICAgICBkZXZpY2VTaXplc1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgY29uZmlnQ29udGV4dFxuICAgIF0pO1xuICAgIGNvbnN0IHsgb25Mb2FkLCBvbkxvYWRpbmdDb21wbGV0ZSB9ID0gcHJvcHM7XG4gICAgY29uc3Qgb25Mb2FkUmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG9uTG9hZCk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIG9uTG9hZFJlZi5jdXJyZW50ID0gb25Mb2FkO1xuICAgIH0sIFtcbiAgICAgICAgb25Mb2FkXG4gICAgXSk7XG4gICAgY29uc3Qgb25Mb2FkaW5nQ29tcGxldGVSZWYgPSAoMCwgX3JlYWN0LnVzZVJlZikob25Mb2FkaW5nQ29tcGxldGUpO1xuICAgICgwLCBfcmVhY3QudXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50ID0gb25Mb2FkaW5nQ29tcGxldGU7XG4gICAgfSwgW1xuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVxuICAgIF0pO1xuICAgIGNvbnN0IFtibHVyQ29tcGxldGUsIHNldEJsdXJDb21wbGV0ZV0gPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgW3Nob3dBbHRUZXh0LCBzZXRTaG93QWx0VGV4dF0gPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgeyBwcm9wczogaW1nQXR0cmlidXRlcywgbWV0YTogaW1nTWV0YSB9ID0gKDAsIF9nZXRpbWdwcm9wcy5nZXRJbWdQcm9wcykocHJvcHMsIHtcbiAgICAgICAgZGVmYXVsdExvYWRlcjogX2ltYWdlbG9hZGVyLmRlZmF1bHQsXG4gICAgICAgIGltZ0NvbmY6IGNvbmZpZyxcbiAgICAgICAgYmx1ckNvbXBsZXRlLFxuICAgICAgICBzaG93QWx0VGV4dFxuICAgIH0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbWFnZUVsZW1lbnQsIHtcbiAgICAgICAgLi4uaW1nQXR0cmlidXRlcyxcbiAgICAgICAgdW5vcHRpbWl6ZWQ6IGltZ01ldGEudW5vcHRpbWl6ZWQsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBpbWdNZXRhLnBsYWNlaG9sZGVyLFxuICAgICAgICBmaWxsOiBpbWdNZXRhLmZpbGwsXG4gICAgICAgIG9uTG9hZFJlZjogb25Mb2FkUmVmLFxuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZjogb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgIHNldEJsdXJDb21wbGV0ZTogc2V0Qmx1ckNvbXBsZXRlLFxuICAgICAgICBzZXRTaG93QWx0VGV4dDogc2V0U2hvd0FsdFRleHQsXG4gICAgICAgIHJlZjogZm9yd2FyZGVkUmVmXG4gICAgfSksIGltZ01ldGEucHJpb3JpdHkgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSW1hZ2VQcmVsb2FkLCB7XG4gICAgICAgIGlzQXBwUm91dGVyOiBpc0FwcFJvdXRlcixcbiAgICAgICAgaW1nQXR0cmlidXRlczogaW1nQXR0cmlidXRlc1xuICAgIH0pIDogbnVsbCk7XG59KTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtY29tcG9uZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJJbWFnZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlYWN0IiwiXyIsIl9yZWFjdGRvbSIsIl9oZWFkIiwiX2dldGltZ3Byb3BzIiwiX2ltYWdlY29uZmlnIiwiX2ltYWdlY29uZmlnY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfd2Fybm9uY2UiLCJfcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfaW1hZ2Vsb2FkZXIiLCJjb25maWdFbnYiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0lNQUdFX09QVFMiLCJnbG9iYWxUaGlzIiwiX19ORVhUX0lNQUdFX0lNUE9SVEVEIiwiaGFuZGxlTG9hZGluZyIsImltZyIsInBsYWNlaG9sZGVyIiwib25Mb2FkUmVmIiwib25Mb2FkaW5nQ29tcGxldGVSZWYiLCJzZXRCbHVyQ29tcGxldGUiLCJ1bm9wdGltaXplZCIsInNyYyIsInAiLCJkZWNvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwidGhlbiIsInBhcmVudEVsZW1lbnQiLCJpc0Nvbm5lY3RlZCIsImN1cnJlbnQiLCJldmVudCIsIkV2ZW50Iiwid3JpdGFibGUiLCJwcmV2ZW50ZWQiLCJzdG9wcGVkIiwibmF0aXZlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwZXJzaXN0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJvcmlnU3JjIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0QXR0cmlidXRlIiwid2lkdGhWaWV3cG9ydFJhdGlvIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwid2Fybk9uY2UiLCJwb3NpdGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJ2YWxpZCIsImluY2x1ZGVzIiwibWFwIiwiU3RyaW5nIiwiam9pbiIsImhlaWdodCIsImhlaWdodE1vZGlmaWVkIiwidG9TdHJpbmciLCJ3aWR0aE1vZGlmaWVkIiwiZ2V0RHluYW1pY1Byb3BzIiwiZmV0Y2hQcmlvcml0eSIsIm1ham9yU3RyIiwibWlub3JTdHIiLCJ2ZXJzaW9uIiwic3BsaXQiLCJtYWpvciIsInBhcnNlSW50IiwibWlub3IiLCJmZXRjaHByaW9yaXR5IiwiSW1hZ2VFbGVtZW50IiwiZm9yd2FyZFJlZiIsInBhcmFtIiwiZm9yd2FyZGVkUmVmIiwic3JjU2V0Iiwic2l6ZXMiLCJkZWNvZGluZyIsImNsYXNzTmFtZSIsInN0eWxlIiwibG9hZGluZyIsImZpbGwiLCJzZXRTaG93QWx0VGV4dCIsIm9uTG9hZCIsIm9uRXJyb3IiLCJyZXN0IiwiZGVmYXVsdCIsImNyZWF0ZUVsZW1lbnQiLCJyZWYiLCJ1c2VDYWxsYmFjayIsImNvbnNvbGUiLCJlcnJvciIsImNvbXBsZXRlIiwiSW1hZ2VQcmVsb2FkIiwiaXNBcHBSb3V0ZXIiLCJpbWdBdHRyaWJ1dGVzIiwib3B0cyIsImFzIiwiaW1hZ2VTcmNTZXQiLCJpbWFnZVNpemVzIiwiY3Jvc3NPcmlnaW4iLCJyZWZlcnJlclBvbGljeSIsInByZWxvYWQiLCJrZXkiLCJyZWwiLCJocmVmIiwidW5kZWZpbmVkIiwicHJvcHMiLCJwYWdlc1JvdXRlciIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiY29uZmlnQ29udGV4dCIsIkltYWdlQ29uZmlnQ29udGV4dCIsImNvbmZpZyIsInVzZU1lbW8iLCJjIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiYWxsU2l6ZXMiLCJkZXZpY2VTaXplcyIsInNvcnQiLCJhIiwiYiIsIm9uTG9hZGluZ0NvbXBsZXRlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiYmx1ckNvbXBsZXRlIiwidXNlU3RhdGUiLCJzaG93QWx0VGV4dCIsIm1ldGEiLCJpbWdNZXRhIiwiZ2V0SW1nUHJvcHMiLCJkZWZhdWx0TG9hZGVyIiwiaW1nQ29uZiIsIkZyYWdtZW50IiwicHJpb3JpdHkiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "../../node_modules/next/dist/client/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/next/dist/client/index.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* global location */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"../../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    version: function() {\n        return version;\n    },\n    router: function() {\n        return router;\n    },\n    emitter: function() {\n        return emitter;\n    },\n    initialize: function() {\n        return initialize;\n    },\n    hydrate: function() {\n        return hydrate;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"../../node_modules/@swc/helpers/esm/_interop_require_default.js\");\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"../../node_modules/next/dist/build/polyfills/polyfill-module.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"../../node_modules/react/index.js\"));\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"../../node_modules/react-dom/client.js\"));\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"../../node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/mitt */ \"../../node_modules/next/dist/shared/lib/mitt.js\"));\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"../../node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ../shared/lib/router/utils/handle-smooth-scroll */ \"../../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _isdynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"../../node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _runtimeconfigexternal = __webpack_require__(/*! ../shared/lib/runtime-config.external */ \"../../node_modules/next/dist/shared/lib/runtime-config.external.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"../../node_modules/next/dist/shared/lib/utils.js\");\nconst _portal = __webpack_require__(/*! ./portal */ \"../../node_modules/next/dist/client/portal/index.js\");\nconst _headmanager = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./head-manager */ \"../../node_modules/next/dist/client/head-manager.js\"));\nconst _pageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./page-loader */ \"../../node_modules/next/dist/client/page-loader.js\"));\nconst _performancerelayer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./performance-relayer */ \"../../node_modules/next/dist/client/performance-relayer.js\"));\nconst _routeannouncer = __webpack_require__(/*! ./route-announcer */ \"../../node_modules/next/dist/client/route-announcer.js\");\nconst _router = __webpack_require__(/*! ./router */ \"../../node_modules/next/dist/client/router.js\");\nconst _iserror = __webpack_require__(/*! ../lib/is-error */ \"../../node_modules/next/dist/lib/is-error.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"../../node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _removebasepath = __webpack_require__(/*! ./remove-base-path */ \"../../node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ./has-base-path */ \"../../node_modules/next/dist/client/has-base-path.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"../../node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _adapters = __webpack_require__(/*! ../shared/lib/router/adapters */ \"../../node_modules/next/dist/shared/lib/router/adapters.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../shared/lib/hooks-client-context.shared-runtime */ \"../../node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _onrecoverableerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./on-recoverable-error */ \"../../node_modules/next/dist/client/on-recoverable-error.js\"));\nconst _tracer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./tracing/tracer */ \"../../node_modules/next/dist/client/tracing/tracer.js\"));\nconst _reporttosocket = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./tracing/report-to-socket */ \"../../node_modules/next/dist/client/tracing/report-to-socket.js\"));\nconst version = \"13.5.11\";\nlet router;\nconst emitter = (0, _mitt.default)();\nconst looseToArray = (input)=>[].slice.call(input);\nlet initialData;\nlet defaultLocale = undefined;\nlet asPath;\nlet pageLoader;\nlet appElement;\nlet headManager;\nlet initialMatchesMiddleware = false;\nlet lastAppProps;\nlet lastRenderReject;\nlet devClient;\nlet CachedApp, onPerfEntry;\nlet CachedComponent;\nclass Container extends _react.default.Component {\n    componentDidCatch(componentErr, info) {\n        this.props.fn(componentErr, info);\n    }\n    componentDidMount() {\n        this.scrollToHash();\n        // We need to replace the router state if:\n        // - the page was (auto) exported and has a query string or search (hash)\n        // - it was auto exported and is a dynamic route (to provide params)\n        // - if it is a client-side skeleton (fallback render)\n        // - if middleware matches the current page (may have rewrite params)\n        // - if rewrites in next.config.js match (may have rewrite params)\n        if (router.isSsr && (initialData.isFallback || initialData.nextExport && ((0, _isdynamic.isDynamicRoute)(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n            // update query on mount for exported pages\n            router.replace(router.pathname + \"?\" + String((0, _querystring.assign)((0, _querystring.urlQueryToSearchParams)(router.query), new URLSearchParams(location.search))), asPath, {\n                // @ts-ignore\n                // WARNING: `_h` is an internal option for handing Next.js\n                // client-side hydration. Your app should _never_ use this property.\n                // It may change at any time without notice.\n                _h: 1,\n                // Fallback pages must trigger the data fetch, so the transition is\n                // not shallow.\n                // Other pages (strictly updating query) happens shallowly, as data\n                // requirements would already be present.\n                shallow: !initialData.isFallback && !initialMatchesMiddleware\n            }).catch((err)=>{\n                if (!err.cancelled) throw err;\n            });\n        }\n    }\n    componentDidUpdate() {\n        this.scrollToHash();\n    }\n    scrollToHash() {\n        let { hash } = location;\n        hash = hash && hash.substring(1);\n        if (!hash) return;\n        const el = document.getElementById(hash);\n        if (!el) return;\n        // If we call scrollIntoView() in here without a setTimeout\n        // it won't scroll properly.\n        setTimeout(()=>el.scrollIntoView(), 0);\n    }\n    render() {\n        if (false) {} else {\n            const { ReactDevOverlay } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"../../node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n            return /*#__PURE__*/ _react.default.createElement(ReactDevOverlay, null, this.props.children);\n        }\n    }\n}\nasync function initialize(opts) {\n    if (opts === void 0) opts = {};\n    _tracer.default.onSpanEnd(_reporttosocket.default);\n    // This makes sure this specific lines are removed in production\n    if (true) {\n        devClient = opts.devClient;\n    }\n    initialData = JSON.parse(document.getElementById(\"__NEXT_DATA__\").textContent);\n    window.__NEXT_DATA__ = initialData;\n    defaultLocale = initialData.defaultLocale;\n    const prefix = initialData.assetPrefix || \"\";\n    self.__next_set_public_path__(\"\" + prefix + \"/_next/\") //eslint-disable-line\n    ;\n    // Initialize next/config with the environment configuration\n    (0, _runtimeconfigexternal.setConfig)({\n        serverRuntimeConfig: {},\n        publicRuntimeConfig: initialData.runtimeConfig || {}\n    });\n    asPath = (0, _utils.getURL)();\n    // make sure not to attempt stripping basePath for 404s\n    if ((0, _hasbasepath.hasBasePath)(asPath)) {\n        asPath = (0, _removebasepath.removeBasePath)(asPath);\n    }\n    if (false) {}\n    if (initialData.scriptLoader) {\n        const { initScriptLoader } = __webpack_require__(/*! ./script */ \"../../node_modules/next/dist/client/script.js\");\n        initScriptLoader(initialData.scriptLoader);\n    }\n    pageLoader = new _pageloader.default(initialData.buildId, prefix);\n    const register = (param)=>{\n        let [r, f] = param;\n        return pageLoader.routeLoader.onEntrypoint(r, f);\n    };\n    if (window.__NEXT_P) {\n        // Defer page registration for another tick. This will increase the overall\n        // latency in hydrating the page, but reduce the total blocking time.\n        window.__NEXT_P.map((p)=>setTimeout(()=>register(p), 0));\n    }\n    window.__NEXT_P = [];\n    window.__NEXT_P.push = register;\n    headManager = (0, _headmanager.default)();\n    headManager.getIsSsr = ()=>{\n        return router.isSsr;\n    };\n    appElement = document.getElementById(\"__next\");\n    return {\n        assetPrefix: prefix\n    };\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ _react.default.createElement(App, appProps);\n}\nfunction AppContainer(param) {\n    _s();\n    let { children } = param;\n    // Create a memoized value for next/navigation router context.\n    const adaptedForAppRouter = _react.default.useMemo(()=>{\n        return (0, _adapters.adaptForAppRouterInstance)(router);\n    }, []);\n    var _self___NEXT_DATA___autoExport;\n    return /*#__PURE__*/ _react.default.createElement(Container, {\n        fn: (error)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderError({\n                App: CachedApp,\n                err: error\n            }).catch((err)=>console.error(\"Error rendering page: \", err))\n    }, /*#__PURE__*/ _react.default.createElement(_approutercontextsharedruntime.AppRouterContext.Provider, {\n        value: adaptedForAppRouter\n    }, /*#__PURE__*/ _react.default.createElement(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n        value: (0, _adapters.adaptForSearchParams)(router)\n    }, /*#__PURE__*/ _react.default.createElement(_adapters.PathnameContextProviderAdapter, {\n        router: router,\n        isAutoExport: (_self___NEXT_DATA___autoExport = self.__NEXT_DATA__.autoExport) != null ? _self___NEXT_DATA___autoExport : false\n    }, /*#__PURE__*/ _react.default.createElement(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n        value: (0, _adapters.adaptForPathParams)(router)\n    }, /*#__PURE__*/ _react.default.createElement(_routercontextsharedruntime.RouterContext.Provider, {\n        value: (0, _router.makePublicRouterInstance)(router)\n    }, /*#__PURE__*/ _react.default.createElement(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n        value: headManager\n    }, /*#__PURE__*/ _react.default.createElement(_imageconfigcontextsharedruntime.ImageConfigContext.Provider, {\n        value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"localhost\"],\"remotePatterns\":[]}\n    }, children))))))));\n}\n_s(AppContainer, \"F6BSfrFQNeqenuPnUMVY/6gI8uE=\");\n_c = AppContainer;\nconst wrapApp = (App)=>(wrappedAppProps)=>{\n        const appProps = {\n            ...wrappedAppProps,\n            Component: CachedComponent,\n            err: initialData.err,\n            router\n        };\n        return /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps));\n    };\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    let { App, err } = renderErrorProps;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        devClient.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        // TODO: Fix disabled eslint rule\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return doRender({\n            App: ()=>null,\n            props: {},\n            Component: ()=>null,\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage(\"/_error\").then((param)=>{\n        let { page: ErrorComponent, styleSheets } = param;\n        return (lastAppProps == null ? void 0 : lastAppProps.Component) === ErrorComponent ? Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_error */ \"../../node_modules/next/dist/pages/_error.js\"))).then((errorModule)=>{\n            return Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_app */ \"../../node_modules/next/dist/pages/_app.js\"))).then((appModule)=>{\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then((m)=>({\n                ErrorComponent: m.default,\n                styleSheets: []\n            })) : {\n            ErrorComponent,\n            styleSheets\n        };\n    }).then((param)=>{\n        let { ErrorComponent, styleSheets } = param;\n        var _renderErrorProps_props;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        const AppTree = wrapApp(App);\n        const appCtx = {\n            Component: ErrorComponent,\n            AppTree,\n            router,\n            ctx: {\n                err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath,\n                AppTree\n            }\n        };\n        return Promise.resolve(((_renderErrorProps_props = renderErrorProps.props) == null ? void 0 : _renderErrorProps_props.err) ? renderErrorProps.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then((initProps)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            doRender({\n                ...renderErrorProps,\n                err,\n                Component: ErrorComponent,\n                styleSheets,\n                props: initProps\n            }));\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    _s1();\n    let { callback } = param;\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect(()=>callback(), [\n        callback\n    ]);\n    return null;\n}\n_s1(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nconst performanceMarks = {\n    navigationStart: \"navigationStart\",\n    beforeRender: \"beforeRender\",\n    afterRender: \"afterRender\",\n    afterHydrate: \"afterHydrate\",\n    routeChange: \"routeChange\"\n};\nconst performanceMeasures = {\n    hydration: \"Next.js-hydration\",\n    beforeHydration: \"Next.js-before-hydration\",\n    routeChangeToRender: \"Next.js-route-change-to-render\",\n    render: \"Next.js-render\"\n};\nlet reactRoot = null;\n// On initial render a hydrate should always happen\nlet shouldHydrate = true;\nfunction clearMarks() {\n    [\n        performanceMarks.beforeRender,\n        performanceMarks.afterHydrate,\n        performanceMarks.afterRender,\n        performanceMarks.routeChange\n    ].forEach((mark)=>performance.clearMarks(mark));\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterHydrate) // mark end of hydration\n    ;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, \"mark\").length;\n    if (hasBeforeRenderMark) {\n        const beforeHydrationMeasure = performance.measure(performanceMeasures.beforeHydration, performanceMarks.navigationStart, performanceMarks.beforeRender);\n        const hydrationMeasure = performance.measure(performanceMeasures.hydration, performanceMarks.beforeRender, performanceMarks.afterHydrate);\n        if ( true && // Old versions of Safari don't return `PerformanceMeasure`s from `performance.measure()`\n        beforeHydrationMeasure !== undefined && hydrationMeasure !== undefined) {\n            _tracer.default.startSpan(\"navigation-to-hydration\", {\n                startTime: performance.timeOrigin + beforeHydrationMeasure.startTime,\n                attributes: {\n                    pathname: location.pathname,\n                    query: location.search\n                }\n            }).end(performance.timeOrigin + hydrationMeasure.startTime + hydrationMeasure.duration);\n        }\n    }\n    if (onPerfEntry) {\n        performance.getEntriesByName(performanceMeasures.hydration).forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterRender) // mark end of render\n    ;\n    const navStartEntries = performance.getEntriesByName(performanceMarks.routeChange, \"mark\");\n    if (!navStartEntries.length) return;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, \"mark\").length;\n    if (hasBeforeRenderMark) {\n        performance.measure(performanceMeasures.routeChangeToRender, navStartEntries[0].name, performanceMarks.beforeRender);\n        performance.measure(performanceMeasures.render, performanceMarks.beforeRender, performanceMarks.afterRender);\n        if (onPerfEntry) {\n            performance.getEntriesByName(performanceMeasures.render).forEach(onPerfEntry);\n            performance.getEntriesByName(performanceMeasures.routeChangeToRender).forEach(onPerfEntry);\n        }\n    }\n    clearMarks();\n    [\n        performanceMeasures.routeChangeToRender,\n        performanceMeasures.render\n    ].forEach((measure)=>performance.clearMeasures(measure));\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(performanceMarks.beforeRender);\n    }\n    const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (!reactRoot) {\n        // Unlike with createRoot, you don't need a separate root.render() call here\n        reactRoot = _client.default.hydrateRoot(domEl, reactEl, {\n            onRecoverableError: _onrecoverableerror.default\n        });\n        // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n        shouldHydrate = false;\n    } else {\n        const startTransition = _react.default.startTransition;\n        startTransition(()=>{\n            reactRoot.render(reactEl);\n        });\n    }\n}\nfunction Root(param) {\n    _s2();\n    let { callbacks, children } = param;\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect(()=>callbacks.forEach((callback)=>callback()), [\n        callbacks\n    ]);\n    // We should ask to measure the Web Vitals after rendering completes so we\n    // don't cause any hydration delay:\n    _react.default.useEffect(()=>{\n        (0, _performancerelayer.default)(onPerfEntry);\n    }, []);\n    if (false) {}\n    return children;\n}\n_s2(Root, \"Gjgl5rfcc2T4sFnfEMfRvL6K4Q4=\");\n_c2 = Root;\nfunction doRender(input) {\n    let { App, Component, props, err } = input;\n    let styleSheets = \"initial\" in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    const appProps = {\n        ...props,\n        Component,\n        err,\n        router\n    };\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    let canceled = false;\n    let resolvePromise;\n    const renderPromise = new Promise((resolve, reject)=>{\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = ()=>{\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = ()=>{\n            canceled = true;\n            lastRenderReject = null;\n            const error = new Error(\"Cancel rendering route\");\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== \"production\") {\n            return false;\n        }\n        const currentStyleTags = looseToArray(document.querySelectorAll(\"style[data-n-href]\"));\n        const currentHrefs = new Set(currentStyleTags.map((tag)=>tag.getAttribute(\"data-n-href\")));\n        const noscript = document.querySelector(\"noscript[data-n-css]\");\n        const nonce = noscript == null ? void 0 : noscript.getAttribute(\"data-n-css\");\n        styleSheets.forEach((param)=>{\n            let { href, text } = param;\n            if (!currentHrefs.has(href)) {\n                const styleTag = document.createElement(\"style\");\n                styleTag.setAttribute(\"data-n-href\", href);\n                styleTag.setAttribute(\"media\", \"x\");\n                if (nonce) {\n                    styleTag.setAttribute(\"nonce\", nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    }\n    function onHeadCommit() {\n        if (// unless we're in production:\n        false) {}\n        if (input.scroll) {\n            const { x, y } = input.scroll;\n            (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n                window.scrollTo(x, y);\n            });\n        }\n    }\n    function onRootCommit() {\n        resolvePromise();\n    }\n    onStart();\n    const elem = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Head, {\n        callback: onHeadCommit\n    }), /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps), /*#__PURE__*/ _react.default.createElement(_portal.Portal, {\n        type: \"next-route-announcer\"\n    }, /*#__PURE__*/ _react.default.createElement(_routeannouncer.RouteAnnouncer, null))));\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, (callback)=>/*#__PURE__*/ _react.default.createElement(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ]\n        },  true ? /*#__PURE__*/ _react.default.createElement(_react.default.StrictMode, null, elem) : 0));\n    return renderPromise;\n}\nasync function render(renderingProps) {\n    if (renderingProps.err) {\n        await renderError(renderingProps);\n        return;\n    }\n    try {\n        await doRender(renderingProps);\n    } catch (err) {\n        const renderErr = (0, _iserror.getProperError)(err);\n        // bubble up cancelation errors\n        if (renderErr.cancelled) {\n            throw renderErr;\n        }\n        if (true) {\n            // Ensure this error is displayed in the overlay in development\n            setTimeout(()=>{\n                throw renderErr;\n            });\n        }\n        await renderError({\n            ...renderingProps,\n            err: renderErr\n        });\n    }\n}\nasync function hydrate(opts) {\n    let initialErr = initialData.err;\n    try {\n        const appEntrypoint = await pageLoader.routeLoader.whenEntrypoint(\"/_app\");\n        if (\"error\" in appEntrypoint) {\n            throw appEntrypoint.error;\n        }\n        const { component: app, exports: mod } = appEntrypoint;\n        CachedApp = app;\n        if (mod && mod.reportWebVitals) {\n            onPerfEntry = (param)=>{\n                let { id, name, startTime, value, duration, entryType, entries, attribution } = param;\n                // Combines timestamp with random number for unique ID\n                const uniqueID = Date.now() + \"-\" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);\n                let perfStartEntry;\n                if (entries && entries.length) {\n                    perfStartEntry = entries[0].startTime;\n                }\n                const webVitals = {\n                    id: id || uniqueID,\n                    name,\n                    startTime: startTime || perfStartEntry,\n                    value: value == null ? duration : value,\n                    label: entryType === \"mark\" || entryType === \"measure\" ? \"custom\" : \"web-vital\"\n                };\n                if (attribution) {\n                    webVitals.attribution = attribution;\n                }\n                mod.reportWebVitals(webVitals);\n            };\n        }\n        const pageEntrypoint = // error, so we need to skip waiting for the entrypoint.\n         true && initialData.err ? {\n            error: initialData.err\n        } : await pageLoader.routeLoader.whenEntrypoint(initialData.page);\n        if (\"error\" in pageEntrypoint) {\n            throw pageEntrypoint.error;\n        }\n        CachedComponent = pageEntrypoint.component;\n        if (true) {\n            const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"../../node_modules/next/dist/compiled/react-is/index.js\");\n            if (!isValidElementType(CachedComponent)) {\n                throw new Error('The default export is not a React Component in page: \"' + initialData.page + '\"');\n            }\n        }\n    } catch (error) {\n        // This catches errors like throwing in the top level of a module\n        initialErr = (0, _iserror.getProperError)(error);\n    }\n    if (true) {\n        const { getServerError } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"../../node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n        // Server-side runtime errors need to be re-thrown on the client-side so\n        // that the overlay is rendered.\n        if (initialErr) {\n            if (initialErr === initialData.err) {\n                setTimeout(()=>{\n                    let error;\n                    try {\n                        // Generate a new error object. We `throw` it because some browsers\n                        // will set the `stack` when thrown, and we want to ensure ours is\n                        // not overridden when we re-throw it below.\n                        throw new Error(initialErr.message);\n                    } catch (e) {\n                        error = e;\n                    }\n                    error.name = initialErr.name;\n                    error.stack = initialErr.stack;\n                    throw getServerError(error, initialErr.source);\n                });\n            } else {\n                setTimeout(()=>{\n                    throw initialErr;\n                });\n            }\n        }\n    }\n    if (window.__NEXT_PRELOADREADY) {\n        await window.__NEXT_PRELOADREADY(initialData.dynamicIds);\n    }\n    router = (0, _router.createRouter)(initialData.page, initialData.query, asPath, {\n        initialProps: initialData.props,\n        pageLoader,\n        App: CachedApp,\n        Component: CachedComponent,\n        wrapApp,\n        err: initialErr,\n        isFallback: Boolean(initialData.isFallback),\n        subscription: (info, App, scroll)=>render(Object.assign({}, info, {\n                App,\n                scroll\n            })),\n        locale: initialData.locale,\n        locales: initialData.locales,\n        defaultLocale,\n        domainLocales: initialData.domainLocales,\n        isPreview: initialData.isPreview\n    });\n    initialMatchesMiddleware = await router._initialMatchesMiddlewarePromise;\n    const renderCtx = {\n        App: CachedApp,\n        initial: true,\n        Component: CachedComponent,\n        props: initialData.props,\n        err: initialErr\n    };\n    if (opts == null ? void 0 : opts.beforeRender) {\n        await opts.beforeRender();\n    }\n    render(renderCtx);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsbUJBQW1CLEdBQWdCOzs7Ozs7QUFDbkNBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBTU47QUFDQSxTQUFTTSxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJWixPQUFPQyxjQUFjLENBQUNVLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUVIsU0FBUztJQUNiRyxTQUFTO1FBQ0wsT0FBT0E7SUFDWDtJQUNBQyxRQUFRO1FBQ0osT0FBT0E7SUFDWDtJQUNBQyxTQUFTO1FBQ0wsT0FBT0E7SUFDWDtJQUNBQyxZQUFZO1FBQ1IsT0FBT0E7SUFDWDtJQUNBQyxTQUFTO1FBQ0wsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU8sMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSEFBeUM7QUFDbEZBLG1CQUFPQSxDQUFDLDJHQUFvQztBQUM1QyxNQUFNQyxTQUFTLFdBQVcsR0FBR0YseUJBQXlCRyxDQUFDLENBQUNGLG1CQUFPQSxDQUFDLGdEQUFPO0FBQ3ZFLE1BQU1HLFVBQVUsV0FBVyxHQUFHSix5QkFBeUJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsZ0VBQWtCO0FBQ25GLE1BQU1JLG1DQUFtQ0osbUJBQU9BLENBQUMseUlBQW1EO0FBQ3BHLE1BQU1LLFFBQVEsV0FBVyxHQUFHTix5QkFBeUJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsMkVBQW9CO0FBQ25GLE1BQU1NLDhCQUE4Qk4sbUJBQU9BLENBQUMsNkhBQTZDO0FBQ3pGLE1BQU1PLHNCQUFzQlAsbUJBQU9BLENBQUMscUlBQWlEO0FBQ3JGLE1BQU1RLGFBQWFSLG1CQUFPQSxDQUFDLGlIQUF1QztBQUNsRSxNQUFNUyxlQUFlVCxtQkFB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QUFjLENBQUNwUSxNQUFNcUYsS0FBSytILFNBQVNqTCxPQUFPdkcsT0FBT3NGLE1BQU0sQ0FBQyxDQUFDLEdBQUdsQixNQUFNO2dCQUMxRHFGO2dCQUNBK0g7WUFDSjtRQUNKbEosUUFBUXBGLFlBQVlvRixNQUFNO1FBQzFCSixTQUFTaEYsWUFBWWdGLE9BQU87UUFDNUIvRTtRQUNBc1IsZUFBZXZSLFlBQVl1UixhQUFhO1FBQ3hDQyxXQUFXeFIsWUFBWXdSLFNBQVM7SUFDcEM7SUFDQWpSLDJCQUEyQixNQUFNbkQsT0FBT3FVLGdDQUFnQztJQUN4RSxNQUFNQyxZQUFZO1FBQ2RuTCxLQUFLNUY7UUFDTGdSLFNBQVM7UUFDVDVRLFdBQVdGO1FBQ1hNLE9BQU9uQixZQUFZbUIsS0FBSztRQUN4QndCLEtBQUsyTTtJQUNUO0lBQ0EsSUFBSTdMLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtnRyxZQUFZLEVBQUU7UUFDM0MsTUFBTWhHLEtBQUtnRyxZQUFZO0lBQzNCO0lBQ0FwRyxPQUFPcU87QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPMVUsUUFBUTJDLE9BQU8sS0FBSyxjQUFlLE9BQU8zQyxRQUFRMkMsT0FBTyxLQUFLLFlBQVkzQyxRQUFRMkMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPM0MsUUFBUTJDLE9BQU8sQ0FBQ2lTLFVBQVUsS0FBSyxhQUFhO0lBQ3JLOVUsT0FBT0MsY0FBYyxDQUFDQyxRQUFRMkMsT0FBTyxFQUFFLGNBQWM7UUFBRTFDLE9BQU87SUFBSztJQUNuRUgsT0FBT3NGLE1BQU0sQ0FBQ3BGLFFBQVEyQyxPQUFPLEVBQUUzQztJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRMkMsT0FBTztBQUNsQyxFQUVBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW5kZXguanM/NDc1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgbG9jYXRpb24gKi8gXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB2ZXJzaW9uOiBudWxsLFxuICAgIHJvdXRlcjogbnVsbCxcbiAgICBlbWl0dGVyOiBudWxsLFxuICAgIGluaXRpYWxpemU6IG51bGwsXG4gICAgaHlkcmF0ZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICB2ZXJzaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgfSxcbiAgICByb3V0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcm91dGVyO1xuICAgIH0sXG4gICAgZW1pdHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpbml0aWFsaXplO1xuICAgIH0sXG4gICAgaHlkcmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoeWRyYXRlO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbnJlcXVpcmUoXCIuLi9idWlsZC9wb2x5ZmlsbHMvcG9seWZpbGwtbW9kdWxlXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX2NsaWVudCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcInJlYWN0LWRvbS9jbGllbnRcIikpO1xuY29uc3QgX2hlYWRtYW5hZ2VyY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9taXR0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9taXR0XCIpKTtcbmNvbnN0IF9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcbmNvbnN0IF9pc2R5bmFtaWMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pY1wiKTtcbmNvbnN0IF9xdWVyeXN0cmluZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZ1wiKTtcbmNvbnN0IF9ydW50aW1lY29uZmlnZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9ydW50aW1lLWNvbmZpZy5leHRlcm5hbFwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xuY29uc3QgX3BvcnRhbCA9IHJlcXVpcmUoXCIuL3BvcnRhbFwiKTtcbmNvbnN0IF9oZWFkbWFuYWdlciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vaGVhZC1tYW5hZ2VyXCIpKTtcbmNvbnN0IF9wYWdlbG9hZGVyID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9wYWdlLWxvYWRlclwiKSk7XG5jb25zdCBfcGVyZm9ybWFuY2VyZWxheWVyID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9wZXJmb3JtYW5jZS1yZWxheWVyXCIpKTtcbmNvbnN0IF9yb3V0ZWFubm91bmNlciA9IHJlcXVpcmUoXCIuL3JvdXRlLWFubm91bmNlclwiKTtcbmNvbnN0IF9yb3V0ZXIgPSByZXF1aXJlKFwiLi9yb3V0ZXJcIik7XG5jb25zdCBfaXNlcnJvciA9IHJlcXVpcmUoXCIuLi9saWIvaXMtZXJyb3JcIik7XG5jb25zdCBfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX3JlbW92ZWJhc2VwYXRoID0gcmVxdWlyZShcIi4vcmVtb3ZlLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuL2hhcy1iYXNlLXBhdGhcIik7XG5jb25zdCBfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfYWRhcHRlcnMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvYWRhcHRlcnNcIik7XG5jb25zdCBfaG9va3NjbGllbnRjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX29ucmVjb3ZlcmFibGVlcnJvciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vb24tcmVjb3ZlcmFibGUtZXJyb3JcIikpO1xuY29uc3QgX3RyYWNlciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vdHJhY2luZy90cmFjZXJcIikpO1xuY29uc3QgX3JlcG9ydHRvc29ja2V0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi90cmFjaW5nL3JlcG9ydC10by1zb2NrZXRcIikpO1xuY29uc3QgdmVyc2lvbiA9IFwiMTMuNS4xMVwiO1xubGV0IHJvdXRlcjtcbmNvbnN0IGVtaXR0ZXIgPSAoMCwgX21pdHQuZGVmYXVsdCkoKTtcbmNvbnN0IGxvb3NlVG9BcnJheSA9IChpbnB1dCk9PltdLnNsaWNlLmNhbGwoaW5wdXQpO1xubGV0IGluaXRpYWxEYXRhO1xubGV0IGRlZmF1bHRMb2NhbGUgPSB1bmRlZmluZWQ7XG5sZXQgYXNQYXRoO1xubGV0IHBhZ2VMb2FkZXI7XG5sZXQgYXBwRWxlbWVudDtcbmxldCBoZWFkTWFuYWdlcjtcbmxldCBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUgPSBmYWxzZTtcbmxldCBsYXN0QXBwUHJvcHM7XG5sZXQgbGFzdFJlbmRlclJlamVjdDtcbmxldCBkZXZDbGllbnQ7XG5sZXQgQ2FjaGVkQXBwLCBvblBlcmZFbnRyeTtcbmxldCBDYWNoZWRDb21wb25lbnQ7XG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQge1xuICAgIGNvbXBvbmVudERpZENhdGNoKGNvbXBvbmVudEVyciwgaW5mbykge1xuICAgICAgICB0aGlzLnByb3BzLmZuKGNvbXBvbmVudEVyciwgaW5mbyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaCgpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlcGxhY2UgdGhlIHJvdXRlciBzdGF0ZSBpZjpcbiAgICAgICAgLy8gLSB0aGUgcGFnZSB3YXMgKGF1dG8pIGV4cG9ydGVkIGFuZCBoYXMgYSBxdWVyeSBzdHJpbmcgb3Igc2VhcmNoIChoYXNoKVxuICAgICAgICAvLyAtIGl0IHdhcyBhdXRvIGV4cG9ydGVkIGFuZCBpcyBhIGR5bmFtaWMgcm91dGUgKHRvIHByb3ZpZGUgcGFyYW1zKVxuICAgICAgICAvLyAtIGlmIGl0IGlzIGEgY2xpZW50LXNpZGUgc2tlbGV0b24gKGZhbGxiYWNrIHJlbmRlcilcbiAgICAgICAgLy8gLSBpZiBtaWRkbGV3YXJlIG1hdGNoZXMgdGhlIGN1cnJlbnQgcGFnZSAobWF5IGhhdmUgcmV3cml0ZSBwYXJhbXMpXG4gICAgICAgIC8vIC0gaWYgcmV3cml0ZXMgaW4gbmV4dC5jb25maWcuanMgbWF0Y2ggKG1heSBoYXZlIHJld3JpdGUgcGFyYW1zKVxuICAgICAgICBpZiAocm91dGVyLmlzU3NyICYmIChpbml0aWFsRGF0YS5pc0ZhbGxiYWNrIHx8IGluaXRpYWxEYXRhLm5leHRFeHBvcnQgJiYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZXIucGF0aG5hbWUpIHx8IGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTIHx8IGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSkgfHwgaW5pdGlhbERhdGEucHJvcHMgJiYgaW5pdGlhbERhdGEucHJvcHMuX19OX1NTRyAmJiAobG9jYXRpb24uc2VhcmNoIHx8IHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgfHwgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlKSkpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBxdWVyeSBvbiBtb3VudCBmb3IgZXhwb3J0ZWQgcGFnZXNcbiAgICAgICAgICAgIHJvdXRlci5yZXBsYWNlKHJvdXRlci5wYXRobmFtZSArIFwiP1wiICsgU3RyaW5nKCgwLCBfcXVlcnlzdHJpbmcuYXNzaWduKSgoMCwgX3F1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMpKHJvdXRlci5xdWVyeSksIG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKSkpLCBhc1BhdGgsIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qc1xuICAgICAgICAgICAgICAgIC8vIGNsaWVudC1zaWRlIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gSXQgbWF5IGNoYW5nZSBhdCBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgICAgICAgICBfaDogMSxcbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBwYWdlcyBtdXN0IHRyaWdnZXIgdGhlIGRhdGEgZmV0Y2gsIHNvIHRoZSB0cmFuc2l0aW9uIGlzXG4gICAgICAgICAgICAgICAgLy8gbm90IHNoYWxsb3cuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXIgcGFnZXMgKHN0cmljdGx5IHVwZGF0aW5nIHF1ZXJ5KSBoYXBwZW5zIHNoYWxsb3dseSwgYXMgZGF0YVxuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVtZW50cyB3b3VsZCBhbHJlYWR5IGJlIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgc2hhbGxvdzogIWluaXRpYWxEYXRhLmlzRmFsbGJhY2sgJiYgIWluaXRpYWxNYXRjaGVzTWlkZGxld2FyZVxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICBpZiAoIWVyci5jYW5jZWxsZWQpIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goKTtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKCkge1xuICAgICAgICBsZXQgeyBoYXNoIH0gPSBsb2NhdGlvbjtcbiAgICAgICAgaGFzaCA9IGhhc2ggJiYgaGFzaC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmICghaGFzaCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpO1xuICAgICAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgICAgIC8vIElmIHdlIGNhbGwgc2Nyb2xsSW50b1ZpZXcoKSBpbiBoZXJlIHdpdGhvdXQgYSBzZXRUaW1lb3V0XG4gICAgICAgIC8vIGl0IHdvbid0IHNjcm9sbCBwcm9wZXJseS5cbiAgICAgICAgc2V0VGltZW91dCgoKT0+ZWwuc2Nyb2xsSW50b1ZpZXcoKSwgMCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IFJlYWN0RGV2T3ZlcmxheSB9ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9kaXN0L2NsaWVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3REZXZPdmVybGF5LCBudWxsLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemUob3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICBfdHJhY2VyLmRlZmF1bHQub25TcGFuRW5kKF9yZXBvcnR0b3NvY2tldC5kZWZhdWx0KTtcbiAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhpcyBzcGVjaWZpYyBsaW5lcyBhcmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgZGV2Q2xpZW50ID0gb3B0cy5kZXZDbGllbnQ7XG4gICAgfVxuICAgIGluaXRpYWxEYXRhID0gSlNPTi5wYXJzZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIl9fTkVYVF9EQVRBX19cIikudGV4dENvbnRlbnQpO1xuICAgIHdpbmRvdy5fX05FWFRfREFUQV9fID0gaW5pdGlhbERhdGE7XG4gICAgZGVmYXVsdExvY2FsZSA9IGluaXRpYWxEYXRhLmRlZmF1bHRMb2NhbGU7XG4gICAgY29uc3QgcHJlZml4ID0gaW5pdGlhbERhdGEuYXNzZXRQcmVmaXggfHwgXCJcIjtcbiAgICBzZWxmLl9fbmV4dF9zZXRfcHVibGljX3BhdGhfXyhcIlwiICsgcHJlZml4ICsgXCIvX25leHQvXCIpIC8vZXNsaW50LWRpc2FibGUtbGluZVxuICAgIDtcbiAgICAvLyBJbml0aWFsaXplIG5leHQvY29uZmlnIHdpdGggdGhlIGVudmlyb25tZW50IGNvbmZpZ3VyYXRpb25cbiAgICAoMCwgX3J1bnRpbWVjb25maWdleHRlcm5hbC5zZXRDb25maWcpKHtcbiAgICAgICAgc2VydmVyUnVudGltZUNvbmZpZzoge30sXG4gICAgICAgIHB1YmxpY1J1bnRpbWVDb25maWc6IGluaXRpYWxEYXRhLnJ1bnRpbWVDb25maWcgfHwge31cbiAgICB9KTtcbiAgICBhc1BhdGggPSAoMCwgX3V0aWxzLmdldFVSTCkoKTtcbiAgICAvLyBtYWtlIHN1cmUgbm90IHRvIGF0dGVtcHQgc3RyaXBwaW5nIGJhc2VQYXRoIGZvciA0MDRzXG4gICAgaWYgKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzUGF0aCkpIHtcbiAgICAgICAgYXNQYXRoID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXNQYXRoKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgY29uc3QgeyBub3JtYWxpemVMb2NhbGVQYXRoIH0gPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbiAgICAgICAgY29uc3QgeyBkZXRlY3REb21haW5Mb2NhbGUgfSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIik7XG4gICAgICAgIGNvbnN0IHsgcGFyc2VSZWxhdGl2ZVVybCB9ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbiAgICAgICAgY29uc3QgeyBmb3JtYXRVcmwgfSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xuICAgICAgICBpZiAoaW5pdGlhbERhdGEubG9jYWxlcykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgaW5pdGlhbERhdGEubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBhc1BhdGggPSBmb3JtYXRVcmwocGFyc2VkQXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZXJpdmUgdGhlIGRlZmF1bHQgbG9jYWxlIGlmIGl0IHdhc24ndCBkZXRlY3RlZCBpbiB0aGUgYXNQYXRoXG4gICAgICAgICAgICAgICAgLy8gc2luY2Ugd2UgZG9uJ3QgcHJlcmVuZGVyIHN0YXRpYyBwYWdlcyB3aXRoIGFsbCBwb3NzaWJsZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gbG9jYWxlc1xuICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGUgPSBpbml0aWFsRGF0YS5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdHRlbXB0IGRldGVjdGluZyBkZWZhdWx0IGxvY2FsZSBiYXNlZCBvbiBob3N0bmFtZVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fRE9NQUlOUywgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGludmVzdGlnYXRlIGlmIGRlZmF1bHRMb2NhbGUgbmVlZHMgdG8gYmUgcG9wdWxhdGVkIGFmdGVyXG4gICAgICAgICAgICAvLyBoeWRyYXRpb24gdG8gcHJldmVudCBtaXNtYXRjaGVkIHJlbmRlcnNcbiAgICAgICAgICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGUgPSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbml0aWFsRGF0YS5zY3JpcHRMb2FkZXIpIHtcbiAgICAgICAgY29uc3QgeyBpbml0U2NyaXB0TG9hZGVyIH0gPSByZXF1aXJlKFwiLi9zY3JpcHRcIik7XG4gICAgICAgIGluaXRTY3JpcHRMb2FkZXIoaW5pdGlhbERhdGEuc2NyaXB0TG9hZGVyKTtcbiAgICB9XG4gICAgcGFnZUxvYWRlciA9IG5ldyBfcGFnZWxvYWRlci5kZWZhdWx0KGluaXRpYWxEYXRhLmJ1aWxkSWQsIHByZWZpeCk7XG4gICAgY29uc3QgcmVnaXN0ZXIgPSAocGFyYW0pPT57XG4gICAgICAgIGxldCBbciwgZl0gPSBwYXJhbTtcbiAgICAgICAgcmV0dXJuIHBhZ2VMb2FkZXIucm91dGVMb2FkZXIub25FbnRyeXBvaW50KHIsIGYpO1xuICAgIH07XG4gICAgaWYgKHdpbmRvdy5fX05FWFRfUCkge1xuICAgICAgICAvLyBEZWZlciBwYWdlIHJlZ2lzdHJhdGlvbiBmb3IgYW5vdGhlciB0aWNrLiBUaGlzIHdpbGwgaW5jcmVhc2UgdGhlIG92ZXJhbGxcbiAgICAgICAgLy8gbGF0ZW5jeSBpbiBoeWRyYXRpbmcgdGhlIHBhZ2UsIGJ1dCByZWR1Y2UgdGhlIHRvdGFsIGJsb2NraW5nIHRpbWUuXG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5tYXAoKHApPT5zZXRUaW1lb3V0KCgpPT5yZWdpc3RlcihwKSwgMCkpO1xuICAgIH1cbiAgICB3aW5kb3cuX19ORVhUX1AgPSBbXTtcbiAgICB3aW5kb3cuX19ORVhUX1AucHVzaCA9IHJlZ2lzdGVyO1xuICAgIGhlYWRNYW5hZ2VyID0gKDAsIF9oZWFkbWFuYWdlci5kZWZhdWx0KSgpO1xuICAgIGhlYWRNYW5hZ2VyLmdldElzU3NyID0gKCk9PntcbiAgICAgICAgcmV0dXJuIHJvdXRlci5pc1NzcjtcbiAgICB9O1xuICAgIGFwcEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIl9fbmV4dFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3NldFByZWZpeDogcHJlZml4XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlckFwcChBcHAsIGFwcFByb3BzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHAsIGFwcFByb3BzKTtcbn1cbmZ1bmN0aW9uIEFwcENvbnRhaW5lcihwYXJhbSkge1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJhbTtcbiAgICAvLyBDcmVhdGUgYSBtZW1vaXplZCB2YWx1ZSBmb3IgbmV4dC9uYXZpZ2F0aW9uIHJvdXRlciBjb250ZXh0LlxuICAgIGNvbnN0IGFkYXB0ZWRGb3JBcHBSb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VNZW1vKCgpPT57XG4gICAgICAgIHJldHVybiAoMCwgX2FkYXB0ZXJzLmFkYXB0Rm9yQXBwUm91dGVySW5zdGFuY2UpKHJvdXRlcik7XG4gICAgfSwgW10pO1xuICAgIHZhciBfc2VsZl9fX05FWFRfREFUQV9fX2F1dG9FeHBvcnQ7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb250YWluZXIsIHtcbiAgICAgICAgZm46IChlcnJvcik9Pi8vIFRPRE86IEZpeCBkaXNhYmxlZCBlc2xpbnQgcnVsZVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgcmVuZGVyRXJyb3Ioe1xuICAgICAgICAgICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICAgICAgICAgIGVycjogZXJyb3JcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT5jb25zb2xlLmVycm9yKFwiRXJyb3IgcmVuZGVyaW5nIHBhZ2U6IFwiLCBlcnIpKVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuQXBwUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogYWRhcHRlZEZvckFwcFJvdXRlclxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaG9va3NjbGllbnRjb250ZXh0c2hhcmVkcnVudGltZS5TZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiAoMCwgX2FkYXB0ZXJzLmFkYXB0Rm9yU2VhcmNoUGFyYW1zKShyb3V0ZXIpXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hZGFwdGVycy5QYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXIsIHtcbiAgICAgICAgcm91dGVyOiByb3V0ZXIsXG4gICAgICAgIGlzQXV0b0V4cG9ydDogKF9zZWxmX19fTkVYVF9EQVRBX19fYXV0b0V4cG9ydCA9IHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0KSAhPSBudWxsID8gX3NlbGZfX19ORVhUX0RBVEFfX19hdXRvRXhwb3J0IDogZmFsc2VcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hvb2tzY2xpZW50Y29udGV4dHNoYXJlZHJ1bnRpbWUuUGF0aFBhcmFtc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6ICgwLCBfYWRhcHRlcnMuYWRhcHRGb3JQYXRoUGFyYW1zKShyb3V0ZXIpXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5Sb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiAoMCwgX3JvdXRlci5tYWtlUHVibGljUm91dGVySW5zdGFuY2UpKHJvdXRlcilcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWRtYW5hZ2VyY29udGV4dHNoYXJlZHJ1bnRpbWUuSGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBoZWFkTWFuYWdlclxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZS5JbWFnZUNvbmZpZ0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTXG4gICAgfSwgY2hpbGRyZW4pKSkpKSkpKTtcbn1cbmNvbnN0IHdyYXBBcHAgPSAoQXBwKT0+KHdyYXBwZWRBcHBQcm9wcyk9PntcbiAgICAgICAgY29uc3QgYXBwUHJvcHMgPSB7XG4gICAgICAgICAgICAuLi53cmFwcGVkQXBwUHJvcHMsXG4gICAgICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgICAgIGVycjogaW5pdGlhbERhdGEuZXJyLFxuICAgICAgICAgICAgcm91dGVyXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGFpbmVyLCBudWxsLCByZW5kZXJBcHAoQXBwLCBhcHBQcm9wcykpO1xuICAgIH07XG4vLyBUaGlzIG1ldGhvZCBoYW5kbGVzIGFsbCBydW50aW1lIGFuZCBkZWJ1ZyBlcnJvcnMuXG4vLyA0MDQgYW5kIDUwMCBlcnJvcnMgYXJlIHNwZWNpYWwga2luZCBvZiBlcnJvcnNcbi8vIGFuZCB0aGV5IGFyZSBzdGlsbCBoYW5kbGUgdmlhIHRoZSBtYWluIHJlbmRlciBtZXRob2QuXG5mdW5jdGlvbiByZW5kZXJFcnJvcihyZW5kZXJFcnJvclByb3BzKSB7XG4gICAgbGV0IHsgQXBwLCBlcnIgfSA9IHJlbmRlckVycm9yUHJvcHM7XG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQgcnVudGltZSBlcnJvcnMgYXJlIGNhdWdodCBieSBvdXIgb3ZlcmxheVxuICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAvLyBBIE5leHQuanMgcmVuZGVyaW5nIHJ1bnRpbWUgZXJyb3IgaXMgYWx3YXlzIHVucmVjb3ZlcmFibGVcbiAgICAgICAgLy8gRklYTUU6IGxldCdzIG1ha2UgdGhpcyByZWNvdmVyYWJsZSAoZXJyb3IgaW4gR0lQIGNsaWVudC10cmFuc2l0aW9uKVxuICAgICAgICBkZXZDbGllbnQub25VbnJlY292ZXJhYmxlRXJyb3IoKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgPEFwcD4gc28gdGhhdCB0aGUgYDxSZWFjdERldk92ZXJsYXk+YCBjYW5cbiAgICAgICAgLy8gcmVuZGVyIGl0c2VsZi5cbiAgICAgICAgLy8gVE9ETzogRml4IGRpc2FibGVkIGVzbGludCBydWxlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIGRvUmVuZGVyKHtcbiAgICAgICAgICAgIEFwcDogKCk9Pm51bGwsXG4gICAgICAgICAgICBwcm9wczoge30sXG4gICAgICAgICAgICBDb21wb25lbnQ6ICgpPT5udWxsLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZSwgb3RoZXJ3aXNlIHVzZXJzIGNhbid0IHRyYWNrIGRvd24gaXNzdWVzLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICBjb25zb2xlLmVycm9yKFwiQSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkLCBzZWUgaGVyZSBmb3IgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9jbGllbnQtc2lkZS1leGNlcHRpb24tb2NjdXJyZWRcIik7XG4gICAgcmV0dXJuIHBhZ2VMb2FkZXIubG9hZFBhZ2UoXCIvX2Vycm9yXCIpLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICBsZXQgeyBwYWdlOiBFcnJvckNvbXBvbmVudCwgc3R5bGVTaGVldHMgfSA9IHBhcmFtO1xuICAgICAgICByZXR1cm4gKGxhc3RBcHBQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogbGFzdEFwcFByb3BzLkNvbXBvbmVudCkgPT09IEVycm9yQ29tcG9uZW50ID8gaW1wb3J0KFwiLi4vcGFnZXMvX2Vycm9yXCIpLnRoZW4oKGVycm9yTW9kdWxlKT0+e1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydChcIi4uL3BhZ2VzL19hcHBcIikudGhlbigoYXBwTW9kdWxlKT0+e1xuICAgICAgICAgICAgICAgIEFwcCA9IGFwcE1vZHVsZS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIHJlbmRlckVycm9yUHJvcHMuQXBwID0gQXBwO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck1vZHVsZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKChtKT0+KHtcbiAgICAgICAgICAgICAgICBFcnJvckNvbXBvbmVudDogbS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICAgICAgfSkpIDoge1xuICAgICAgICAgICAgRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICBzdHlsZVNoZWV0c1xuICAgICAgICB9O1xuICAgIH0pLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICBsZXQgeyBFcnJvckNvbXBvbmVudCwgc3R5bGVTaGVldHMgfSA9IHBhcmFtO1xuICAgICAgICB2YXIgX3JlbmRlckVycm9yUHJvcHNfcHJvcHM7XG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgZG8gYSBub3JtYWwgcmVuZGVyIHdpdGggdGhlIGBFcnJvckNvbXBvbmVudGAgYXMgY29tcG9uZW50LlxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gaGVyZSB1cG9uIGluaXRpYWwgcmVuZGVyLCB3ZSBjYW4gdXNlIHRoZSBwcm9wcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBjYWxsIGBnZXRJbml0aWFsUHJvcHNgIG9uIGBBcHBgIGJlZm9yZSBtb3VudGluZy5cbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHdyYXBBcHAoQXBwKTtcbiAgICAgICAgY29uc3QgYXBwQ3R4ID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWU6IGluaXRpYWxEYXRhLnBhZ2UsXG4gICAgICAgICAgICAgICAgcXVlcnk6IGluaXRpYWxEYXRhLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzUGF0aCxcbiAgICAgICAgICAgICAgICBBcHBUcmVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKChfcmVuZGVyRXJyb3JQcm9wc19wcm9wcyA9IHJlbmRlckVycm9yUHJvcHMucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfcmVuZGVyRXJyb3JQcm9wc19wcm9wcy5lcnIpID8gcmVuZGVyRXJyb3JQcm9wcy5wcm9wcyA6ICgwLCBfdXRpbHMubG9hZEdldEluaXRpYWxQcm9wcykoQXBwLCBhcHBDdHgpKS50aGVuKChpbml0UHJvcHMpPT4vLyBUT0RPOiBGaXggZGlzYWJsZWQgZXNsaW50IHJ1bGVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgIGRvUmVuZGVyKHtcbiAgICAgICAgICAgICAgICAuLi5yZW5kZXJFcnJvclByb3BzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBDb21wb25lbnQ6IEVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgIHByb3BzOiBpbml0UHJvcHNcbiAgICAgICAgICAgIH0pKTtcbiAgICB9KTtcbn1cbi8vIER1bW15IGNvbXBvbmVudCB0aGF0IHdlIHJlbmRlciBhcyBhIGNoaWxkIG9mIFJvb3Qgc28gdGhhdCB3ZSBjYW5cbi8vIHRvZ2dsZSB0aGUgY29ycmVjdCBzdHlsZXMgYmVmb3JlIHRoZSBwYWdlIGlzIHJlbmRlcmVkLlxuZnVuY3Rpb24gSGVhZChwYXJhbSkge1xuICAgIGxldCB7IGNhbGxiYWNrIH0gPSBwYXJhbTtcbiAgICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZFxuICAgIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlLlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+Y2FsbGJhY2soKSwgW1xuICAgICAgICBjYWxsYmFja1xuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgcGVyZm9ybWFuY2VNYXJrcyA9IHtcbiAgICBuYXZpZ2F0aW9uU3RhcnQ6IFwibmF2aWdhdGlvblN0YXJ0XCIsXG4gICAgYmVmb3JlUmVuZGVyOiBcImJlZm9yZVJlbmRlclwiLFxuICAgIGFmdGVyUmVuZGVyOiBcImFmdGVyUmVuZGVyXCIsXG4gICAgYWZ0ZXJIeWRyYXRlOiBcImFmdGVySHlkcmF0ZVwiLFxuICAgIHJvdXRlQ2hhbmdlOiBcInJvdXRlQ2hhbmdlXCJcbn07XG5jb25zdCBwZXJmb3JtYW5jZU1lYXN1cmVzID0ge1xuICAgIGh5ZHJhdGlvbjogXCJOZXh0LmpzLWh5ZHJhdGlvblwiLFxuICAgIGJlZm9yZUh5ZHJhdGlvbjogXCJOZXh0LmpzLWJlZm9yZS1oeWRyYXRpb25cIixcbiAgICByb3V0ZUNoYW5nZVRvUmVuZGVyOiBcIk5leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlclwiLFxuICAgIHJlbmRlcjogXCJOZXh0LmpzLXJlbmRlclwiXG59O1xubGV0IHJlYWN0Um9vdCA9IG51bGw7XG4vLyBPbiBpbml0aWFsIHJlbmRlciBhIGh5ZHJhdGUgc2hvdWxkIGFsd2F5cyBoYXBwZW5cbmxldCBzaG91bGRIeWRyYXRlID0gdHJ1ZTtcbmZ1bmN0aW9uIGNsZWFyTWFya3MoKSB7XG4gICAgW1xuICAgICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcixcbiAgICAgICAgcGVyZm9ybWFuY2VNYXJrcy5hZnRlckh5ZHJhdGUsXG4gICAgICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJSZW5kZXIsXG4gICAgICAgIHBlcmZvcm1hbmNlTWFya3Mucm91dGVDaGFuZ2VcbiAgICBdLmZvckVhY2goKG1hcmspPT5wZXJmb3JtYW5jZS5jbGVhck1hcmtzKG1hcmspKTtcbn1cbmZ1bmN0aW9uIG1hcmtIeWRyYXRlQ29tcGxldGUoKSB7XG4gICAgaWYgKCFfdXRpbHMuU1QpIHJldHVybjtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlKSAvLyBtYXJrIGVuZCBvZiBoeWRyYXRpb25cbiAgICA7XG4gICAgY29uc3QgaGFzQmVmb3JlUmVuZGVyTWFyayA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUocGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIsIFwibWFya1wiKS5sZW5ndGg7XG4gICAgaWYgKGhhc0JlZm9yZVJlbmRlck1hcmspIHtcbiAgICAgICAgY29uc3QgYmVmb3JlSHlkcmF0aW9uTWVhc3VyZSA9IHBlcmZvcm1hbmNlLm1lYXN1cmUocGVyZm9ybWFuY2VNZWFzdXJlcy5iZWZvcmVIeWRyYXRpb24sIHBlcmZvcm1hbmNlTWFya3MubmF2aWdhdGlvblN0YXJ0LCBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcik7XG4gICAgICAgIGNvbnN0IGh5ZHJhdGlvbk1lYXN1cmUgPSBwZXJmb3JtYW5jZS5tZWFzdXJlKHBlcmZvcm1hbmNlTWVhc3VyZXMuaHlkcmF0aW9uLCBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlciwgcGVyZm9ybWFuY2VNYXJrcy5hZnRlckh5ZHJhdGUpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJiAvLyBPbGQgdmVyc2lvbnMgb2YgU2FmYXJpIGRvbid0IHJldHVybiBgUGVyZm9ybWFuY2VNZWFzdXJlYHMgZnJvbSBgcGVyZm9ybWFuY2UubWVhc3VyZSgpYFxuICAgICAgICBiZWZvcmVIeWRyYXRpb25NZWFzdXJlICE9PSB1bmRlZmluZWQgJiYgaHlkcmF0aW9uTWVhc3VyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdHJhY2VyLmRlZmF1bHQuc3RhcnRTcGFuKFwibmF2aWdhdGlvbi10by1oeWRyYXRpb25cIiwge1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogcGVyZm9ybWFuY2UudGltZU9yaWdpbiArIGJlZm9yZUh5ZHJhdGlvbk1lYXN1cmUuc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogbG9jYXRpb24uc2VhcmNoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuZW5kKHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gKyBoeWRyYXRpb25NZWFzdXJlLnN0YXJ0VGltZSArIGh5ZHJhdGlvbk1lYXN1cmUuZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvblBlcmZFbnRyeSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKHBlcmZvcm1hbmNlTWVhc3VyZXMuaHlkcmF0aW9uKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTtcbiAgICB9XG4gICAgY2xlYXJNYXJrcygpO1xufVxuZnVuY3Rpb24gbWFya1JlbmRlckNvbXBsZXRlKCkge1xuICAgIGlmICghX3V0aWxzLlNUKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWFyayhwZXJmb3JtYW5jZU1hcmtzLmFmdGVyUmVuZGVyKSAvLyBtYXJrIGVuZCBvZiByZW5kZXJcbiAgICA7XG4gICAgY29uc3QgbmF2U3RhcnRFbnRyaWVzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShwZXJmb3JtYW5jZU1hcmtzLnJvdXRlQ2hhbmdlLCBcIm1hcmtcIik7XG4gICAgaWYgKCFuYXZTdGFydEVudHJpZXMubGVuZ3RoKSByZXR1cm47XG4gICAgY29uc3QgaGFzQmVmb3JlUmVuZGVyTWFyayA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUocGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIsIFwibWFya1wiKS5sZW5ndGg7XG4gICAgaWYgKGhhc0JlZm9yZVJlbmRlck1hcmspIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShwZXJmb3JtYW5jZU1lYXN1cmVzLnJvdXRlQ2hhbmdlVG9SZW5kZXIsIG5hdlN0YXJ0RW50cmllc1swXS5uYW1lLCBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcik7XG4gICAgICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUocGVyZm9ybWFuY2VNZWFzdXJlcy5yZW5kZXIsIHBlcmZvcm1hbmNlTWFya3MuYmVmb3JlUmVuZGVyLCBwZXJmb3JtYW5jZU1hcmtzLmFmdGVyUmVuZGVyKTtcbiAgICAgICAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKHBlcmZvcm1hbmNlTWVhc3VyZXMucmVuZGVyKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUocGVyZm9ybWFuY2VNZWFzdXJlcy5yb3V0ZUNoYW5nZVRvUmVuZGVyKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhck1hcmtzKCk7XG4gICAgW1xuICAgICAgICBwZXJmb3JtYW5jZU1lYXN1cmVzLnJvdXRlQ2hhbmdlVG9SZW5kZXIsXG4gICAgICAgIHBlcmZvcm1hbmNlTWVhc3VyZXMucmVuZGVyXG4gICAgXS5mb3JFYWNoKChtZWFzdXJlKT0+cGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlKSk7XG59XG5mdW5jdGlvbiByZW5kZXJSZWFjdEVsZW1lbnQoZG9tRWwsIGZuKSB7XG4gICAgLy8gbWFyayBzdGFydCBvZiBoeWRyYXRlL3JlbmRlclxuICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyayhwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcik7XG4gICAgfVxuICAgIGNvbnN0IHJlYWN0RWwgPSBmbihzaG91bGRIeWRyYXRlID8gbWFya0h5ZHJhdGVDb21wbGV0ZSA6IG1hcmtSZW5kZXJDb21wbGV0ZSk7XG4gICAgaWYgKCFyZWFjdFJvb3QpIHtcbiAgICAgICAgLy8gVW5saWtlIHdpdGggY3JlYXRlUm9vdCwgeW91IGRvbid0IG5lZWQgYSBzZXBhcmF0ZSByb290LnJlbmRlcigpIGNhbGwgaGVyZVxuICAgICAgICByZWFjdFJvb3QgPSBfY2xpZW50LmRlZmF1bHQuaHlkcmF0ZVJvb3QoZG9tRWwsIHJlYWN0RWwsIHtcbiAgICAgICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcjogX29ucmVjb3ZlcmFibGVlcnJvci5kZWZhdWx0XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgc2hvdWxkSHlkcmF0ZSB2YXJpYWJsZSB3aGVuIFJlYWN0IDE4IGlzIHN0YWJsZSBhcyBpdCBjYW4gZGVwZW5kIG9uIGByZWFjdFJvb3RgIGV4aXN0aW5nXG4gICAgICAgIHNob3VsZEh5ZHJhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzdGFydFRyYW5zaXRpb24gPSBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb247XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgcmVhY3RSb290LnJlbmRlcihyZWFjdEVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gUm9vdChwYXJhbSkge1xuICAgIGxldCB7IGNhbGxiYWNrcywgY2hpbGRyZW4gfSA9IHBhcmFtO1xuICAgIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrcyBhcmUgZXhlY3V0ZWRcbiAgICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZVxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+Y2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKT0+Y2FsbGJhY2soKSksIFtcbiAgICAgICAgY2FsbGJhY2tzXG4gICAgXSk7XG4gICAgLy8gV2Ugc2hvdWxkIGFzayB0byBtZWFzdXJlIHRoZSBXZWIgVml0YWxzIGFmdGVyIHJlbmRlcmluZyBjb21wbGV0ZXMgc28gd2VcbiAgICAvLyBkb24ndCBjYXVzZSBhbnkgaHlkcmF0aW9uIGRlbGF5OlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAoMCwgX3BlcmZvcm1hbmNlcmVsYXllci5kZWZhdWx0KShvblBlcmZFbnRyeSk7XG4gICAgfSwgW10pO1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gZG9SZW5kZXIoaW5wdXQpIHtcbiAgICBsZXQgeyBBcHAsIENvbXBvbmVudCwgcHJvcHMsIGVyciB9ID0gaW5wdXQ7XG4gICAgbGV0IHN0eWxlU2hlZXRzID0gXCJpbml0aWFsXCIgaW4gaW5wdXQgPyB1bmRlZmluZWQgOiBpbnB1dC5zdHlsZVNoZWV0cztcbiAgICBDb21wb25lbnQgPSBDb21wb25lbnQgfHwgbGFzdEFwcFByb3BzLkNvbXBvbmVudDtcbiAgICBwcm9wcyA9IHByb3BzIHx8IGxhc3RBcHBQcm9wcy5wcm9wcztcbiAgICBjb25zdCBhcHBQcm9wcyA9IHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgZXJyLFxuICAgICAgICByb3V0ZXJcbiAgICB9O1xuICAgIC8vIGxhc3RBcHBQcm9wcyBoYXMgdG8gYmUgc2V0IGJlZm9yZSBSZWFjdERvbS5yZW5kZXIgdG8gYWNjb3VudCBmb3IgUmVhY3REb20gdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgbGFzdEFwcFByb3BzID0gYXBwUHJvcHM7XG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgbGV0IHJlc29sdmVQcm9taXNlO1xuICAgIGNvbnN0IHJlbmRlclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBpZiAobGFzdFJlbmRlclJlamVjdCkge1xuICAgICAgICAgICAgbGFzdFJlbmRlclJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVQcm9taXNlID0gKCk9PntcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJDYW5jZWwgcmVuZGVyaW5nIHJvdXRlXCIpO1xuICAgICAgICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgYSByZXR1cm4gdHlwZSB0byBlbnN1cmUgaXQgZG9lc24ndCBzdGFydCByZXR1cm5pbmcgYVxuICAgIC8vIFByb21pc2UuIEl0IHNob3VsZCByZW1haW4gc3luY2hyb25vdXMuXG4gICAgZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgICAgaWYgKCFzdHlsZVNoZWV0cyB8fCAvLyBXZSB1c2UgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgICAgLy8gdW5sZXNzIHdlJ3JlIGluIHByb2R1Y3Rpb246XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZVRhZ3MgPSBsb29zZVRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInN0eWxlW2RhdGEtbi1ocmVmXVwiKSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRIcmVmcyA9IG5ldyBTZXQoY3VycmVudFN0eWxlVGFncy5tYXAoKHRhZyk9PnRhZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW4taHJlZlwiKSkpO1xuICAgICAgICBjb25zdCBub3NjcmlwdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJub3NjcmlwdFtkYXRhLW4tY3NzXVwiKTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBub3NjcmlwdCA9PSBudWxsID8gdm9pZCAwIDogbm9zY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1uLWNzc1wiKTtcbiAgICAgICAgc3R5bGVTaGVldHMuZm9yRWFjaCgocGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgeyBocmVmLCB0ZXh0IH0gPSBwYXJhbTtcbiAgICAgICAgICAgIGlmICghY3VycmVudEhyZWZzLmhhcyhocmVmKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZShcImRhdGEtbi1ocmVmXCIsIGhyZWYpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIFwieFwiKTtcbiAgICAgICAgICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25IZWFkQ29tbWl0KCkge1xuICAgICAgICBpZiAoLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgJiYgLy8gV2UgY2FuIHNraXAgdGhpcyBkdXJpbmcgaHlkcmF0aW9uLiBSdW5uaW5nIGl0IHdvbnQgY2F1c2UgYW55IGhhcm0sIGJ1dFxuICAgICAgICAvLyB3ZSBtYXkgYXMgd2VsbCBzYXZlIHRoZSBDUFUgY3ljbGVzOlxuICAgICAgICBzdHlsZVNoZWV0cyAmJiAvLyBFbnN1cmUgdGhpcyByZW5kZXIgd2FzIG5vdCBjYW5jZWxlZFxuICAgICAgICAhY2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRIcmVmcyA9IG5ldyBTZXQoc3R5bGVTaGVldHMubWFwKChzKT0+cy5ocmVmKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzID0gbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVtkYXRhLW4taHJlZl1cIikpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEhyZWZzID0gY3VycmVudFN0eWxlVGFncy5tYXAoKHRhZyk9PnRhZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW4taHJlZlwiKSk7XG4gICAgICAgICAgICAvLyBUb2dnbGUgYDxzdHlsZT5gIHRhZ3Mgb24gb3Igb2ZmIGRlcGVuZGluZyBvbiBpZiB0aGV5J3JlIG5lZWRlZDpcbiAgICAgICAgICAgIGZvcihsZXQgaWR4ID0gMDsgaWR4IDwgY3VycmVudEhyZWZzLmxlbmd0aDsgKytpZHgpe1xuICAgICAgICAgICAgICAgIGlmIChkZXNpcmVkSHJlZnMuaGFzKGN1cnJlbnRIcmVmc1tpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGVUYWdzW2lkeF0ucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIFwieFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW9yZGVyIHN0eWxlcyBpbnRvIGludGVuZGVkIG9yZGVyOlxuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZU5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibm9zY3JpcHRbZGF0YS1uLWNzc11cIik7XG4gICAgICAgICAgICBpZiAoLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBocmVmIH0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1uLWhyZWY9XCInICsgaHJlZiArICdcIl0nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC8vIFRoaXMgc2hvdWxkIGJlIGFuIGludmFyaWFudDpcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhcmdldFRhZywgcmVmZXJlbmNlTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlID0gdGFyZ2V0VGFnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCBjbGVhbiB1cCBzZXJ2ZXIgcmVuZGVyZWQgc3R5bGVzaGVldHM6XG4gICAgICAgICAgICBsb29zZVRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtbZGF0YS1uLXBdXCIpKS5mb3JFYWNoKChlbCk9PntcbiAgICAgICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC5zY3JvbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gaW5wdXQuc2Nyb2xsO1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+e1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUm9vdENvbW1pdCgpIHtcbiAgICAgICAgcmVzb2x2ZVByb21pc2UoKTtcbiAgICB9XG4gICAgb25TdGFydCgpO1xuICAgIGNvbnN0IGVsZW0gPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIZWFkLCB7XG4gICAgICAgIGNhbGxiYWNrOiBvbkhlYWRDb21taXRcbiAgICB9KSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lciwgbnVsbCwgcmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3BvcnRhbC5Qb3J0YWwsIHtcbiAgICAgICAgdHlwZTogXCJuZXh0LXJvdXRlLWFubm91bmNlclwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZWFubm91bmNlci5Sb3V0ZUFubm91bmNlciwgbnVsbCkpKSk7XG4gICAgLy8gV2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgcmVuZGVyUmVhY3RFbGVtZW50KGFwcEVsZW1lbnQsIChjYWxsYmFjayk9Pi8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSb290LCB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBvblJvb3RDb21taXRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSwgcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN0cmljdE1vZGUsIG51bGwsIGVsZW0pIDogZWxlbSkpO1xuICAgIHJldHVybiByZW5kZXJQcm9taXNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmluZ1Byb3BzKSB7XG4gICAgaWYgKHJlbmRlcmluZ1Byb3BzLmVycikge1xuICAgICAgICBhd2FpdCByZW5kZXJFcnJvcihyZW5kZXJpbmdQcm9wcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZG9SZW5kZXIocmVuZGVyaW5nUHJvcHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCByZW5kZXJFcnIgPSAoMCwgX2lzZXJyb3IuZ2V0UHJvcGVyRXJyb3IpKGVycik7XG4gICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxhdGlvbiBlcnJvcnNcbiAgICAgICAgaWYgKHJlbmRlckVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRocm93IHJlbmRlckVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoaXMgZXJyb3IgaXMgZGlzcGxheWVkIGluIHRoZSBvdmVybGF5IGluIGRldmVsb3BtZW50XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVuZGVyRXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVuZGVyRXJyb3Ioe1xuICAgICAgICAgICAgLi4ucmVuZGVyaW5nUHJvcHMsXG4gICAgICAgICAgICBlcnI6IHJlbmRlckVyclxuICAgICAgICB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBoeWRyYXRlKG9wdHMpIHtcbiAgICBsZXQgaW5pdGlhbEVyciA9IGluaXRpYWxEYXRhLmVycjtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhcHBFbnRyeXBvaW50ID0gYXdhaXQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludChcIi9fYXBwXCIpO1xuICAgICAgICBpZiAoXCJlcnJvclwiIGluIGFwcEVudHJ5cG9pbnQpIHtcbiAgICAgICAgICAgIHRocm93IGFwcEVudHJ5cG9pbnQuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCwgZXhwb3J0czogbW9kIH0gPSBhcHBFbnRyeXBvaW50O1xuICAgICAgICBDYWNoZWRBcHAgPSBhcHA7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLnJlcG9ydFdlYlZpdGFscykge1xuICAgICAgICAgICAgb25QZXJmRW50cnkgPSAocGFyYW0pPT57XG4gICAgICAgICAgICAgICAgbGV0IHsgaWQsIG5hbWUsIHN0YXJ0VGltZSwgdmFsdWUsIGR1cmF0aW9uLCBlbnRyeVR5cGUsIGVudHJpZXMsIGF0dHJpYnV0aW9uIH0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICAvLyBDb21iaW5lcyB0aW1lc3RhbXAgd2l0aCByYW5kb20gbnVtYmVyIGZvciB1bmlxdWUgSURcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVJRCA9IERhdGUubm93KCkgKyBcIi1cIiArIChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoOWUxMiAtIDEpKSArIDFlMTIpO1xuICAgICAgICAgICAgICAgIGxldCBwZXJmU3RhcnRFbnRyeTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcyAmJiBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwZXJmU3RhcnRFbnRyeSA9IGVudHJpZXNbMF0uc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3ZWJWaXRhbHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCB8fCB1bmlxdWVJRCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUgfHwgcGVyZlN0YXJ0RW50cnksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSA9PSBudWxsID8gZHVyYXRpb24gOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGVudHJ5VHlwZSA9PT0gXCJtYXJrXCIgfHwgZW50cnlUeXBlID09PSBcIm1lYXN1cmVcIiA/IFwiY3VzdG9tXCIgOiBcIndlYi12aXRhbFwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgd2ViVml0YWxzLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZC5yZXBvcnRXZWJWaXRhbHMod2ViVml0YWxzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFnZUVudHJ5cG9pbnQgPSAvLyBUaGUgZGV2IHNlcnZlciBmYWlscyB0byBzZXJ2ZSBzY3JpcHQgYXNzZXRzIHdoZW4gdGhlcmUncyBhIGh5ZHJhdGlvblxuICAgICAgICAvLyBlcnJvciwgc28gd2UgbmVlZCB0byBza2lwIHdhaXRpbmcgZm9yIHRoZSBlbnRyeXBvaW50LlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiICYmIGluaXRpYWxEYXRhLmVyciA/IHtcbiAgICAgICAgICAgIGVycm9yOiBpbml0aWFsRGF0YS5lcnJcbiAgICAgICAgfSA6IGF3YWl0IHBhZ2VMb2FkZXIucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQoaW5pdGlhbERhdGEucGFnZSk7XG4gICAgICAgIGlmIChcImVycm9yXCIgaW4gcGFnZUVudHJ5cG9pbnQpIHtcbiAgICAgICAgICAgIHRocm93IHBhZ2VFbnRyeXBvaW50LmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIENhY2hlZENvbXBvbmVudCA9IHBhZ2VFbnRyeXBvaW50LmNvbXBvbmVudDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXNcIik7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDYWNoZWRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJyArIGluaXRpYWxEYXRhLnBhZ2UgKyAnXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFRoaXMgY2F0Y2hlcyBlcnJvcnMgbGlrZSB0aHJvd2luZyBpbiB0aGUgdG9wIGxldmVsIG9mIGEgbW9kdWxlXG4gICAgICAgIGluaXRpYWxFcnIgPSAoMCwgX2lzZXJyb3IuZ2V0UHJvcGVyRXJyb3IpKGVycm9yKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgY29uc3QgeyBnZXRTZXJ2ZXJFcnJvciB9ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9kaXN0L2NsaWVudFwiKTtcbiAgICAgICAgLy8gU2VydmVyLXNpZGUgcnVudGltZSBlcnJvcnMgbmVlZCB0byBiZSByZS10aHJvd24gb24gdGhlIGNsaWVudC1zaWRlIHNvXG4gICAgICAgIC8vIHRoYXQgdGhlIG92ZXJsYXkgaXMgcmVuZGVyZWQuXG4gICAgICAgIGlmIChpbml0aWFsRXJyKSB7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbEVyciA9PT0gaW5pdGlhbERhdGEuZXJyKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyBlcnJvciBvYmplY3QuIFdlIGB0aHJvd2AgaXQgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHNldCB0aGUgYHN0YWNrYCB3aGVuIHRocm93biwgYW5kIHdlIHdhbnQgdG8gZW5zdXJlIG91cnMgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvdmVycmlkZGVuIHdoZW4gd2UgcmUtdGhyb3cgaXQgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5pdGlhbEVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBpbml0aWFsRXJyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gaW5pdGlhbEVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZ2V0U2VydmVyRXJyb3IoZXJyb3IsIGluaXRpYWxFcnIuc291cmNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWSkge1xuICAgICAgICBhd2FpdCB3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWShpbml0aWFsRGF0YS5keW5hbWljSWRzKTtcbiAgICB9XG4gICAgcm91dGVyID0gKDAsIF9yb3V0ZXIuY3JlYXRlUm91dGVyKShpbml0aWFsRGF0YS5wYWdlLCBpbml0aWFsRGF0YS5xdWVyeSwgYXNQYXRoLCB7XG4gICAgICAgIGluaXRpYWxQcm9wczogaW5pdGlhbERhdGEucHJvcHMsXG4gICAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgd3JhcEFwcCxcbiAgICAgICAgZXJyOiBpbml0aWFsRXJyLFxuICAgICAgICBpc0ZhbGxiYWNrOiBCb29sZWFuKGluaXRpYWxEYXRhLmlzRmFsbGJhY2spLFxuICAgICAgICBzdWJzY3JpcHRpb246IChpbmZvLCBBcHAsIHNjcm9sbCk9PnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCBpbmZvLCB7XG4gICAgICAgICAgICAgICAgQXBwLFxuICAgICAgICAgICAgICAgIHNjcm9sbFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBsb2NhbGU6IGluaXRpYWxEYXRhLmxvY2FsZSxcbiAgICAgICAgbG9jYWxlczogaW5pdGlhbERhdGEubG9jYWxlcyxcbiAgICAgICAgZGVmYXVsdExvY2FsZSxcbiAgICAgICAgZG9tYWluTG9jYWxlczogaW5pdGlhbERhdGEuZG9tYWluTG9jYWxlcyxcbiAgICAgICAgaXNQcmV2aWV3OiBpbml0aWFsRGF0YS5pc1ByZXZpZXdcbiAgICB9KTtcbiAgICBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUgPSBhd2FpdCByb3V0ZXIuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2U7XG4gICAgY29uc3QgcmVuZGVyQ3R4ID0ge1xuICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgIHByb3BzOiBpbml0aWFsRGF0YS5wcm9wcyxcbiAgICAgICAgZXJyOiBpbml0aWFsRXJyXG4gICAgfTtcbiAgICBpZiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgYXdhaXQgb3B0cy5iZWZvcmVSZW5kZXIoKTtcbiAgICB9XG4gICAgcmVuZGVyKHJlbmRlckN0eCk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInZlcnNpb24iLCJyb3V0ZXIiLCJlbWl0dGVyIiwiaW5pdGlhbGl6ZSIsImh5ZHJhdGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsIl9jbGllbnQiLCJfaGVhZG1hbmFnZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9taXR0IiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX2hhbmRsZXNtb290aHNjcm9sbCIsIl9pc2R5bmFtaWMiLCJfcXVlcnlzdHJpbmciLCJfcnVudGltZWNvbmZpZ2V4dGVybmFsIiwiX3V0aWxzIiwiX3BvcnRhbCIsIl9oZWFkbWFuYWdlciIsIl9wYWdlbG9hZGVyIiwiX3BlcmZvcm1hbmNlcmVsYXllciIsIl9yb3V0ZWFubm91bmNlciIsIl9yb3V0ZXIiLCJfaXNlcnJvciIsIl9pbWFnZWNvbmZpZ2NvbnRleHRzaGFyZWRydW50aW1lIiwiX3JlbW92ZWJhc2VwYXRoIiwiX2hhc2Jhc2VwYXRoIiwiX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX2FkYXB0ZXJzIiwiX2hvb2tzY2xpZW50Y29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfb25yZWNvdmVyYWJsZWVycm9yIiwiX3RyYWNlciIsIl9yZXBvcnR0b3NvY2tldCIsImRlZmF1bHQiLCJsb29zZVRvQXJyYXkiLCJpbnB1dCIsInNsaWNlIiwiY2FsbCIsImluaXRpYWxEYXRhIiwiZGVmYXVsdExvY2FsZSIsInVuZGVmaW5lZCIsImFzUGF0aCIsInBhZ2VMb2FkZXIiLCJhcHBFbGVtZW50IiwiaGVhZE1hbmFnZXIiLCJpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUiLCJsYXN0QXBwUHJvcHMiLCJsYXN0UmVuZGVyUmVqZWN0IiwiZGV2Q2xpZW50IiwiQ2FjaGVkQXBwIiwib25QZXJmRW50cnkiLCJDYWNoZWRDb21wb25lbnQiLCJDb250YWluZXIiLCJDb21wb25lbnQiLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudEVyciIsImluZm8iLCJwcm9wcyIsImZuIiwiY29tcG9uZW50RGlkTW91bnQiLCJzY3JvbGxUb0hhc2giLCJpc1NzciIsImlzRmFsbGJhY2siLCJuZXh0RXhwb3J0IiwiaXNEeW5hbWljUm91dGUiLCJwYXRobmFtZSIsImxvY2F0aW9uIiwic2VhcmNoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJfX05fU1NHIiwicmVwbGFjZSIsIlN0cmluZyIsImFzc2lnbiIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJxdWVyeSIsIlVSTFNlYXJjaFBhcmFtcyIsIl9oIiwic2hhbGxvdyIsImNhdGNoIiwiZXJyIiwiY2FuY2VsbGVkIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiaGFzaCIsInN1YnN0cmluZyIsImVsIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInNldFRpbWVvdXQiLCJzY3JvbGxJbnRvVmlldyIsInJlbmRlciIsImNoaWxkcmVuIiwiUmVhY3REZXZPdmVybGF5IiwiY3JlYXRlRWxlbWVudCIsIm9wdHMiLCJvblNwYW5FbmQiLCJKU09OIiwicGFyc2UiLCJ0ZXh0Q29udGVudCIsIndpbmRvdyIsIl9fTkVYVF9EQVRBX18iLCJwcmVmaXgiLCJhc3NldFByZWZpeCIsInNlbGYiLCJfX25leHRfc2V0X3B1YmxpY19wYXRoX18iLCJzZXRDb25maWciLCJzZXJ2ZXJSdW50aW1lQ29uZmlnIiwicHVibGljUnVudGltZUNvbmZpZyIsInJ1bnRpbWVDb25maWciLCJnZXRVUkwiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJwYXJzZVJlbGF0aXZlVXJsIiwiZm9ybWF0VXJsIiwibG9jYWxlcyIsInBhcnNlZEFzIiwibG9jYWxlUGF0aFJlc3VsdCIsImRldGVjdGVkTG9jYWxlIiwibG9jYWxlIiwiZGV0ZWN0ZWREb21haW4iLCJfX05FWFRfSTE4Tl9ET01BSU5TIiwiaG9zdG5hbWUiLCJzY3JpcHRMb2FkZXIiLCJpbml0U2NyaXB0TG9hZGVyIiwiYnVpbGRJZCIsInJlZ2lzdGVyIiwicGFyYW0iLCJyIiwiZiIsInJvdXRlTG9hZGVyIiwib25FbnRyeXBvaW50IiwiX19ORVhUX1AiLCJtYXAiLCJwIiwicHVzaCIsImdldElzU3NyIiwicmVuZGVyQXBwIiwiQXBwIiwiYXBwUHJvcHMiLCJBcHBDb250YWluZXIiLCJhZGFwdGVkRm9yQXBwUm91dGVyIiwidXNlTWVtbyIsImFkYXB0Rm9yQXBwUm91dGVySW5zdGFuY2UiLCJfc2VsZl9fX05FWFRfREFUQV9fX2F1dG9FeHBvcnQiLCJlcnJvciIsInJlbmRlckVycm9yIiwiY29uc29sZSIsIkFwcFJvdXRlckNvbnRleHQiLCJQcm92aWRlciIsIlNlYXJjaFBhcmFtc0NvbnRleHQiLCJhZGFwdEZvclNlYXJjaFBhcmFtcyIsIlBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlciIsImlzQXV0b0V4cG9ydCIsImF1dG9FeHBvcnQiLCJQYXRoUGFyYW1zQ29udGV4dCIsImFkYXB0Rm9yUGF0aFBhcmFtcyIsIlJvdXRlckNvbnRleHQiLCJtYWtlUHVibGljUm91dGVySW5zdGFuY2UiLCJIZWFkTWFuYWdlckNvbnRleHQiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJfX05FWFRfSU1BR0VfT1BUUyIsIndyYXBBcHAiLCJ3cmFwcGVkQXBwUHJvcHMiLCJyZW5kZXJFcnJvclByb3BzIiwib25VbnJlY292ZXJhYmxlRXJyb3IiLCJkb1JlbmRlciIsInN0eWxlU2hlZXRzIiwibG9hZFBhZ2UiLCJ0aGVuIiwicGFnZSIsIkVycm9yQ29tcG9uZW50IiwiZXJyb3JNb2R1bGUiLCJhcHBNb2R1bGUiLCJtIiwiX3JlbmRlckVycm9yUHJvcHNfcHJvcHMiLCJBcHBUcmVlIiwiYXBwQ3R4IiwiY3R4IiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiaW5pdFByb3BzIiwiSGVhZCIsImNhbGxiYWNrIiwidXNlTGF5b3V0RWZmZWN0IiwicGVyZm9ybWFuY2VNYXJrcyIsIm5hdmlnYXRpb25TdGFydCIsImJlZm9yZVJlbmRlciIsImFmdGVyUmVuZGVyIiwiYWZ0ZXJIeWRyYXRlIiwicm91dGVDaGFuZ2UiLCJwZXJmb3JtYW5jZU1lYXN1cmVzIiwiaHlkcmF0aW9uIiwiYmVmb3JlSHlkcmF0aW9uIiwicm91dGVDaGFuZ2VUb1JlbmRlciIsInJlYWN0Um9vdCIsInNob3VsZEh5ZHJhdGUiLCJjbGVhck1hcmtzIiwiZm9yRWFjaCIsIm1hcmsiLCJwZXJmb3JtYW5jZSIsIm1hcmtIeWRyYXRlQ29tcGxldGUiLCJTVCIsImhhc0JlZm9yZVJlbmRlck1hcmsiLCJnZXRFbnRyaWVzQnlOYW1lIiwibGVuZ3RoIiwiYmVmb3JlSHlkcmF0aW9uTWVhc3VyZSIsIm1lYXN1cmUiLCJoeWRyYXRpb25NZWFzdXJlIiwic3RhcnRTcGFuIiwic3RhcnRUaW1lIiwidGltZU9yaWdpbiIsImF0dHJpYnV0ZXMiLCJlbmQiLCJkdXJhdGlvbiIsIm1hcmtSZW5kZXJDb21wbGV0ZSIsIm5hdlN0YXJ0RW50cmllcyIsImNsZWFyTWVhc3VyZXMiLCJyZW5kZXJSZWFjdEVsZW1lbnQiLCJkb21FbCIsInJlYWN0RWwiLCJoeWRyYXRlUm9vdCIsIm9uUmVjb3ZlcmFibGVFcnJvciIsInN0YXJ0VHJhbnNpdGlvbiIsIlJvb3QiLCJjYWxsYmFja3MiLCJ1c2VFZmZlY3QiLCJfX05FWFRfVEVTVF9NT0RFIiwiX19ORVhUX0hZRFJBVEVEIiwiX19ORVhUX0hZRFJBVEVEX0NCIiwiY2FuY2VsZWQiLCJyZXNvbHZlUHJvbWlzZSIsInJlbmRlclByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsIm9uU3RhcnQiLCJjdXJyZW50U3R5bGVUYWdzIiwicXVlcnlTZWxlY3RvckFsbCIsImN1cnJlbnRIcmVmcyIsIlNldCIsInRhZyIsImdldEF0dHJpYnV0ZSIsIm5vc2NyaXB0IiwicXVlcnlTZWxlY3RvciIsIm5vbmNlIiwiaHJlZiIsInRleHQiLCJoYXMiLCJzdHlsZVRhZyIsInNldEF0dHJpYnV0ZSIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwib25IZWFkQ29tbWl0IiwiZGVzaXJlZEhyZWZzIiwicyIsImlkeCIsInJlbW92ZUF0dHJpYnV0ZSIsInJlZmVyZW5jZU5vZGUiLCJ0YXJnZXRUYWciLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwibmV4dFNpYmxpbmciLCJyZW1vdmVDaGlsZCIsInNjcm9sbCIsIngiLCJ5IiwiaGFuZGxlU21vb3RoU2Nyb2xsIiwic2Nyb2xsVG8iLCJvblJvb3RDb21taXQiLCJlbGVtIiwiRnJhZ21lbnQiLCJQb3J0YWwiLCJ0eXBlIiwiUm91dGVBbm5vdW5jZXIiLCJfX05FWFRfU1RSSUNUX01PREUiLCJTdHJpY3RNb2RlIiwicmVuZGVyaW5nUHJvcHMiLCJyZW5kZXJFcnIiLCJnZXRQcm9wZXJFcnJvciIsImluaXRpYWxFcnIiLCJhcHBFbnRyeXBvaW50Iiwid2hlbkVudHJ5cG9pbnQiLCJjb21wb25lbnQiLCJhcHAiLCJtb2QiLCJyZXBvcnRXZWJWaXRhbHMiLCJpZCIsImVudHJ5VHlwZSIsImVudHJpZXMiLCJhdHRyaWJ1dGlvbiIsInVuaXF1ZUlEIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInBlcmZTdGFydEVudHJ5Iiwid2ViVml0YWxzIiwibGFiZWwiLCJwYWdlRW50cnlwb2ludCIsImlzVmFsaWRFbGVtZW50VHlwZSIsImdldFNlcnZlckVycm9yIiwibWVzc2FnZSIsImUiLCJzdGFjayIsInNvdXJjZSIsIl9fTkVYVF9QUkVMT0FEUkVBRFkiLCJkeW5hbWljSWRzIiwiY3JlYXRlUm91dGVyIiwiaW5pdGlhbFByb3BzIiwiQm9vbGVhbiIsInN1YnNjcmlwdGlvbiIsImRvbWFpbkxvY2FsZXMiLCJpc1ByZXZpZXciLCJfaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSIsInJlbmRlckN0eCIsImluaXRpYWwiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/client/index.js\n"));

/***/ })

});